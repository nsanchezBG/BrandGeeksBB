<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Burger Run</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        /* Estilos generales del cuerpo */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #ffffff; /* Fondo blanco */
            font-family: 'VT323', monospace; /* Fuente principal del juego */
            overflow: hidden; /* Evita barras de desplazamiento en el área de juego */
        }
        /* Contenedor principal del juego */
        #game-container {
            width: 400px; /* 10 tiles de ancho */
            height: 600px; /* 15 tiles de alto */
            background-color: #ffffff; /* Color de fondo blanco para las filas */
            position: relative;
            overflow: hidden;
            border: 2px solid #333;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            /* Asegurar que el contenedor sea táctil */
            touch-action: none; 
        }
        /* Estilo para cada carril (fila) */
        .lane {
            width: 100%;
            height: 40px; /* TILE_SIZE */
            position: absolute;
            left: 0;
            display: flex;
            align-items: center;
            background-color: #ffffff; /* Todas las filas son blancas */
        }
        /* Estilo para el jugador */
        #player {
            width: 36px; /* Ligeramente más pequeño que TILE_SIZE para espacio visual */
            height: 36px;
            position: absolute;
            transition: left 0.1s linear, top 0.1s linear;
            z-index: 10;
            box-sizing: border-box;
            /* PNG del jugador */
            background-image: url('https://i.ibb.co/jP49jhv1/player.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        /* Estilo para los obstáculos */
        .obstacle {
            height: 36px; /* Altura consistente con el tamaño del tile */
            position: absolute;
            border: 2px solid #000000; /* Borde negro */
            box-sizing: border-box;
            background-color: #000000; /* Obstáculos negros */
            z-index: 5; /* Asegura que los obstáculos se muestren sobre el carril */
        }
        /* Estilo para las monedas */
        .coin {
            width: 20px; /* Tamaño ajustado para la imagen de la moneda */
            height: 20px; /* Tamaño ajustado para la imagen de la moneda */
            position: absolute;
            z-index: 5;
            /* PNG de la moneda */
            background-image: url('https://i.ibb.co/bjW4KsPS/hamburger-411275.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        /* Marcador de puntuación */
        #score-board {
            margin-top: 10px;
            font-size: 24px; /* Tamaño base para los números */
            color: #000000; /* Texto negro para contraste */
            font-family: 'VT323', monospace; /* Aplicar fuente */
            display: flex; /* Usar flexbox para alinear elementos */
            justify-content: space-around; /* Espacio equitativo entre elementos */
            align-items: center; /* Alinear verticalmente */
            width: 400px; /* Ancho igual al contenedor del juego */
            padding: 5px 0;
        }
        #score-board .score-item {
            display: flex;
            flex-direction: column; /* Apilar texto y número */
            align-items: center; /* Centrar horizontalmente */
            text-align: center; /* Asegurar centrado del texto */
            gap: 0px; /* Eliminar espacio entre texto y número */
        }
        #score-board .score-text {
            font-size: 18px; /* Tamaño más pequeño para el texto */
            line-height: 1; /* Ajustar altura de línea para compactar */
        }
        #score-board .score-number {
            font-size: 24px; /* Mantener tamaño para el número */
            line-height: 1; /* Ajustar altura de línea para compactar */
        }
        #score-board img {
            width: auto; /* Ancho automático para mantener proporción */
            height: 50px; /* Altura del logo para ocupar 2 líneas de texto, ajustar si es necesario */
            margin: 0 10px; /* Pequeño margen a los lados del logo */
        }
        /* Mensaje de fin de juego */
        #game-over-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 20px;
            z-index: 100;
            display: none; /* Oculto por defecto */
        }
        #game-over-message button {
            padding: 10px 20px;
            font-size: 18px;
            margin-top: 15px;
            cursor: pointer;
            background-color: #ffffff; /* Botón blanco */
            color: #000000; /* Texto negro */
            border: 2px solid #000000;
            border-radius: 5px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
            font-family: 'VT323', monospace; /* Aplicar fuente */
        }
        #game-over-message button:hover {
            background-color: #e0e0e0;
            box-shadow: 3px 3px 7px rgba(0,0,0,0.4);
        }
        /* Pantalla de inicio */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #ffffff; /* Pantalla completamente blanca */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #000000; /* Texto negro */
            z-index: 1000;
            text-align: center;
            padding: 0 20px; /* Márgenes a izquierda y derecha para el contenido */
            box-sizing: border-box; /* Incluir padding en el ancho total */
        }
        #start-screen h1 { 
            font-size: 36px; /* Más pequeño que 40px */
            margin-bottom: 10px; 
            text-shadow: 2px 2px #000;
            font-family: 'VT323', monospace; /* Aplicar fuente */
            color: #000000; /* Asegurar color negro */
        }
        #start-screen p { 
            font-size: 16px; /* Más pequeño que 18px */
            margin-bottom: 20px; 
            font-family: 'VT323', monospace; /* Aplicar fuente */
            color: #000000; /* Asegurar color negro */
        }
        #start-button {
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            background-color: #000000; /* Botón negro */
            color: white; /* Letra blanca */
            border: none;
            border-radius: 5px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
            font-family: 'VT323', monospace; /* Aplicar fuente */
        }
        #start-button:hover {
            background-color: #333333; /* Un poco más claro al pasar el ratón */
            box-shadow: 3px 3px 7px rgba(0,0,0,0.4);
        }
        /* Estilo para el nuevo logo de la pantalla de inicio */
        #start-screen-logo {
            width: 150px; /* Ajusta el tamaño del logo según sea necesario */
            height: auto;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="player"></div>
        <div id="start-screen">
            <img id="start-screen-logo" src="https://i.ibb.co/rKdjZkM8/descarga-1.png" alt="Burger Logo">
            <h1>BURGER RUN</h1>
            <p>Esquiva los obstáculos y come todas las burgers que puedas.</p>
            <button id="start-button">JUGAR</button>
        </div>
        <div id="game-over-message">
            <p id="game-over-text">¡Perdiste!</p>
            <p>Tu puntaje final: <span id="final-score">0</span></p>
            <button id="restart-button">Reiniciar</button>
        </div>
    </div>
    <div id="score-board">
        <div class="score-item">
            <span class="score-text">Filas avanzadas:</span>
            <span id="score" class="score-number">0</span>
        </div>
        <img src="https://i.ibb.co/rKdjZkM8/descarga-1.png" alt="Burger Logo Score">
        <div class="score-item">
            <span class="score-text">Burgers comidas:</span>
            <span id="coins" class="score-number">0</span>
        </div>
    </div>

    <script>
        // Obtener referencias a los elementos del DOM
        const gameContainer = document.getElementById('game-container');
        const player = document.getElementById('player');
        const scoreDisplay = document.getElementById('score');
        const coinsDisplay = document.getElementById('coins');
        const gameOverMessage = document.getElementById('game-over-message');
        const finalScoreDisplay = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const gameOverText = document.getElementById('game-over-text'); // Nuevo elemento para el texto de game over

        // Constantes del juego
        const TILE_SIZE = 40; // Tamaño de cada "baldosa" o celda
        const GAME_WIDTH_TILES = 10; // Ancho del juego en número de baldosas
        const GAME_HEIGHT_TILES = 15; // Filas visibles en pantalla
        const TOTAL_LANES_BUFFER = 20; // Número total de filas generadas (incluye las fuera de pantalla)

        // Variables de estado del juego
        let playerPos = { x: 0, y: 0 }; // Posición del jugador en unidades de baldosa
        let score = 0; // Filas avanzadas
        let coins = 0; // Monedas recolectadas
        let lanes = []; // Array que almacena los datos de cada fila
        let gameOver = false; // Indica si el juego ha terminado
        let gameLoopId; // ID del frame de animación
        let currentMaxY = 0; // La fila más lejana alcanzada por el jugador
        let gameStarted = false; // Indica si el juego ha comenzado

        // Parámetros de dificultad
        const INITIAL_SAFE_LANES = 5; // Número de filas iniciales seguras (hierba)
        const DIFFICULTY_INCREASE_INTERVAL = 20; // Intervalo de puntuación para aumentar la dificultad
        const MAX_OBSTACLE_SPEED = 4; // Velocidad máxima para los obstáculos
        const MIN_OBSTACLE_SPEED = 1; // Velocidad mínima para los obstáculos

        // Tipos de carriles permitidos (solo hierba y asfalto)
        const laneTypes = ['grass', 'road'];
        // Tipos de obstáculos (coches en asfalto, cuadrados en hierba)
        const obstacleTypes = {
            road: [{ type: 'car', width: 2 }], // Los coches tienen un ancho de 2 baldosas
            grass: [{ type: 'square_obstacle', width: 1 }] // Nuevo obstáculo para hierba: un cuadrado negro
        };

        /**
         * Crea un elemento de carril (div) y lo añade al contenedor del juego.
         * @param {string} type - Tipo de carril ('grass' o 'road').
         * @param {number} yPos - Posición Y del carril en unidades de baldosa.
         * @returns {HTMLElement} El elemento div del carril creado.
         */
        function createLaneElement(type, yPos) {
            const laneDiv = document.createElement('div');
            laneDiv.classList.add('lane', type);
            laneDiv.style.bottom = (yPos * TILE_SIZE) + 'px'; // Posicionar desde abajo
            gameContainer.appendChild(laneDiv);
            return laneDiv;
        }

        /**
         * Crea un elemento de obstáculo (div) y lo añade al carril especificado.
         * @param {object} lane - Objeto del carril al que se añade el obstáculo.
         * @param {object} obsData - Datos del obstáculo (tipo, ancho).
         * @returns {HTMLElement} El elemento div del obstáculo creado.
         */
        function createObstacleElement(lane, obsData) {
            const obsDiv = document.createElement('div');
            obsDiv.classList.add('obstacle', obsData.type);
            obsDiv.style.width = (obsData.width * TILE_SIZE - 4) + 'px'; // -4 para el borde
            // El color del obstáculo se define en CSS como negro
            obsDiv.style.position = 'absolute'; // Los obstáculos se posicionan absolutamente dentro de su carril
            lane.element.appendChild(obsDiv); // Añadir al elemento DOM del carril
            return obsDiv;
        }
        
        /**
         * Crea un elemento de moneda (div) y lo añade al carril especificado.
         * @param {object} lane - Objeto del carril al que se añade la moneda.
         * @param {number} xPosTile - Posición X de la moneda en unidades de baldosa.
         * @returns {HTMLElement} El elemento div de la moneda creado.
         */
        function createCoinElement(lane, xPosTile) {
            const coinDiv = document.createElement('div');
            coinDiv.classList.add('coin');
            // Posición izquierda ajustada para centrar la imagen de la moneda (20x20px)
            coinDiv.style.left = (xPosTile * TILE_SIZE + (TILE_SIZE - 20) / 2) + 'px';
            coinDiv.style.top = ((TILE_SIZE - 20) / 2) + 'px'; // Centrar verticalmente en el carril
            lane.element.appendChild(coinDiv);
            return coinDiv;
        }

        /**
         * Genera los datos y el elemento DOM para una nueva fila del juego.
         * @param {number} yPos - Posición Y del carril en unidades de baldosa.
         * @returns {object} Objeto que contiene los datos del carril.
         */
        function generateLane(yPos) {
            let type;
            let currentDifficultyLevel = Math.floor(score / DIFFICULTY_INCREASE_INTERVAL);

            // Asegurar que las filas iniciales sean seguras (hierba)
            if (yPos < INITIAL_SAFE_LANES) {
                type = 'grass';
            } else {
                // Aumentar la probabilidad de carriles de asfalto a medida que aumenta la dificultad
                let randomValue = Math.random();
                if (currentDifficultyLevel === 0) { // Juego temprano, principalmente hierba
                    type = (randomValue < 0.8) ? 'grass' : 'road';
                } else if (currentDifficultyLevel === 1) { // Dificultad media
                    type = (randomValue < 0.5) ? 'grass' : 'road';
                } else { // Dificultad alta, más variedad
                    type = laneTypes[Math.floor(Math.random() * laneTypes.length)];
                }
            }

            const laneElement = createLaneElement(type, yPos);
            // Calcular la velocidad de los obstáculos basada en la dificultad
            let newSpeed = MIN_OBSTACLE_SPEED + (MAX_OBSTACLE_SPEED - MIN_OBSTACLE_SPEED) * (currentDifficultyLevel / 10);
            newSpeed = Math.min(newSpeed, MAX_OBSTACLE_SPEED); // Asegurar que la velocidad no exceda el máximo

            // Asegurar que la velocidad sea diferente a la del carril anterior para mayor variedad
            if (yPos > 0 && lanes[yPos - 1]) {
                const prevLaneSpeed = lanes[yPos - 1].speed;
                while (newSpeed === prevLaneSpeed) {
                    newSpeed = MIN_OBSTACLE_SPEED + Math.random() * (MAX_OBSTACLE_SPEED - MIN_OBSTACLE_SPEED);
                    newSpeed = Math.min(newSpeed, MAX_OBSTACLE_SPEED);
                }
            }

            const laneData = {
                y: yPos,
                type: type,
                element: laneElement,
                obstacles: [],
                coins: [], // Array para objetos de moneda
                direction: (Math.random() < 0.5 ? 1 : -1), // Dirección del movimiento de obstáculos
                speed: newSpeed // Velocidad asignada
            };

            // Generación de obstáculos
            if (type === 'road') {
                let currentX = (laneData.direction === 1) ? -TILE_SIZE * 3 : GAME_WIDTH_TILES * TILE_SIZE;
                let numObstacles = 0;

                // Ajustar el número de obstáculos según la dificultad
                if (currentDifficultyLevel === 0) { // Fácil: 0-1 obstáculos
                    numObstacles = Math.random() < 0.6 ? 0 : 1; // Mayor probabilidad de 0 obstáculos
                } else if (currentDifficultyLevel === 1) { // Medio: 1-2 obstáculos
                    numObstacles = Math.floor(Math.random() * 2) + 1;
                } else { // Difícil: 2-3 obstáculos
                    numObstacles = Math.floor(Math.random() * 2) + 2;
                }

                for (let i = 0; i < numObstacles; i++) {
                    const obsTemplate = obstacleTypes[type][Math.floor(Math.random() * obstacleTypes[type].length)];
                    const obsElement = createObstacleElement(laneData, obsTemplate);
                    
                    let obsXPos;
                    if (laneData.direction === 1) {
                        obsXPos = currentX;
                        currentX -= (obsTemplate.width + (2 + Math.random() * 3)) * TILE_SIZE; // Espaciado
                    } else {
                        obsXPos = currentX;
                        currentX += (obsTemplate.width + (2 + Math.random() * 3)) * TILE_SIZE; // Espaciado
                    }
                    
                    laneData.obstacles.push({
                        element: obsElement,
                        x: obsXPos, // Posición en píxeles para el movimiento
                        width: obsTemplate.width * TILE_SIZE,
                        type: obsTemplate.type,
                        initialX: obsXPos // Almacenar X inicial para reinicio
                    });
                    obsElement.style.left = obsXPos + 'px'; // Asegurar que la posición se aplique al elemento
                }
            } else if (type === 'grass') {
                // Añadir monedas a algunas filas de hierba
                if (Math.random() < 0.2) {
                    const coinXTile = Math.floor(Math.random() * GAME_WIDTH_TILES);
                    const coinElement = createCoinElement(laneData, coinXTile);
                    laneData.coins.push({
                        element: coinElement,
                        x: coinXTile * TILE_SIZE, // Posición en píxeles para la colisión
                        y: 0, // Relativo al carril
                        collected: false
                    });
                }

                // Añadir nuevo obstáculo cuadrado_negro en filas de hierba (máximo 1 por fila)
                if (Math.random() < 0.3) { // 30% de probabilidad de añadir un obstáculo cuadrado
                    const obsTemplate = obstacleTypes.grass[0]; // Solo hay un tipo de obstáculo para hierba
                    const obsElement = createObstacleElement(laneData, obsTemplate);
                    
                    // Posicionar el obstáculo cuadrado aleatoriamente en el carril de hierba
                    const obsXPos = Math.floor(Math.random() * (GAME_WIDTH_TILES - obsTemplate.width + 1)) * TILE_SIZE;

                    laneData.obstacles.push({
                        element: obsElement,
                        x: obsXPos,
                        width: obsTemplate.width * TILE_SIZE,
                        type: obsTemplate.type,
                        initialX: obsXPos
                    });
                    obsElement.style.left = obsXPos + 'px'; // ¡Esta línea es la corrección clave!
                }
            }
            return laneData;
        }

        /**
         * Inicializa todas las filas del juego, eliminando las existentes y creando nuevas.
         */
        function initLanes() {
            lanes.forEach(lane => {
                if (lane.element) gameContainer.removeChild(lane.element);
            });
            lanes = [];
            for (let i = 0; i < TOTAL_LANES_BUFFER; i++) {
                lanes.push(generateLane(i));
            }
        }

        /**
         * Actualiza la posición visual del jugador en la pantalla.
         */
        function updatePlayerPosition() {
            player.style.left = (playerPos.x * TILE_SIZE) + 'px'; 
            player.style.bottom = (playerPos.y * TILE_SIZE) + 'px';
        }

        /**
         * Mueve al jugador en la dirección especificada.
         * @param {number} dx - Cambio en la posición X (en unidades de baldosa).
         * @param {number} dy - Cambio en la posición Y (en unidades de baldosa).
         */
        function movePlayer(dx, dy) {
            if (gameOver) return;

            const newX = playerPos.x + dx;
            const newY = playerPos.y + dy;

            // Comprobaciones de límites
            if (newX < 0 || newX >= GAME_WIDTH_TILES) return;
            if (newY < 0) return; // No se permite el movimiento hacia atrás

            playerPos.x = newX;
            playerPos.y = newY;
            
            if (dy > 0) { // Si el jugador se movió hacia adelante
                if (newY > currentMaxY) {
                    score++; // Aumentar la puntuación por fila avanzada
                    currentMaxY = newY;
                    scoreDisplay.textContent = score;

                    // Comprobar si se necesitan generar nuevas filas
                    if (lanes[lanes.length -1].y < playerPos.y + GAME_HEIGHT_TILES) {
                       addNewLaneAtTop();
                    }
                }
            }
            
            // Desplazamiento de la pantalla: Mover todo el contenido del contenedor del juego
            const scrollOffset = Math.max(0, (playerPos.y - Math.floor(GAME_HEIGHT_TILES / 2.5)) * TILE_SIZE);
            lanes.forEach(lane => {
                lane.element.style.transform = `translateY(${scrollOffset}px)`;
            });
            player.style.transform = `translateY(${scrollOffset}px)`;

            updatePlayerPosition(); // Actualización visual del jugador
            checkCollisions(); // Comprobar colisiones después del movimiento
        }
        
        /**
         * Añade una nueva fila en la parte superior del área de juego visible.
         */
        function addNewLaneAtTop() {
            const newLaneY = lanes[lanes.length - 1].y + 1;
            lanes.push(generateLane(newLaneY));

            // Opcional: Eliminar muy antiguas que están muy por debajo del jugador
            if (lanes.length > TOTAL_LANES_BUFFER + 5) {
                const oldLane = lanes.shift();
                if(oldLane.element.parentNode) {
                    gameContainer.removeChild(oldLane.element);
                }
            }
        }

        /**
         * Mueve los obstáculos en sus respectivos carriles.
         */
        function moveObstacles() {
            lanes.forEach(lane => {
                // Solo mover obstáculos en carriles de asfalto
                if (lane.type === 'road') {
                    lane.obstacles.forEach(obs => {
                        obs.x += lane.speed * lane.direction; 
                        // Reiniciar la posición del obstáculo si se sale de la pantalla
                        if (lane.direction === 1 && obs.x > GAME_WIDTH_TILES * TILE_SIZE) {
                            obs.x = -obs.width; // Reiniciar a la izquierda
                        } else if (lane.direction === -1 && obs.x + obs.width < 0) {
                            obs.x = GAME_WIDTH_TILES * TILE_SIZE; // Reiniciar a la derecha
                        }
                        obs.element.style.left = obs.x + 'px';
                    });
                }
                // Los obstáculos de tipo 'grass' (square_obstacle) son estáticos, no se mueven.
            });
        }

        /**
         * Comprueba las colisiones entre el jugador y los obstáculos o monedas.
         */
        function checkCollisions() {
            if (gameOver) return;
            const playerRect = {
                x: playerPos.x * TILE_SIZE,
                y: playerPos.y * TILE_SIZE, // Posición Y base del carril del jugador
                width: TILE_SIZE,
                height: TILE_SIZE
            };
            
            const currentLane = lanes.find(l => l.y === playerPos.y);
            if (!currentLane) {
                console.warn("El jugador está en un carril inexistente:", playerPos.y);
                setGameOver();
                return;
            }

            // Colección de monedas
            if (currentLane.type === 'grass' && currentLane.coins) {
                currentLane.coins.forEach((coin, index) => {
                    if (!coin.collected) {
                        const coinRect = {
                            x: coin.x + (TILE_SIZE - 20) / 2, // X de la moneda es relativo al inicio del carril, ajustado para centrar
                            y: currentLane.y * TILE_SIZE + (TILE_SIZE - 20) / 2, // Usar Y absoluto del carril, ajustado para centrar
                            width: 20, height: 20
                        };
                         // Colisión AABB para la moneda
                        if (playerRect.x < coinRect.x + coinRect.width &&
                            playerRect.x + playerRect.width > coinRect.x &&
                            playerRect.y < coinRect.y + coinRect.height &&
                            playerRect.y + playerRect.height > coinRect.y) {
                            
                            coin.collected = true;
                            if(coin.element.parentNode) coin.element.parentNode.removeChild(coin.element); // Eliminar moneda visualmente
                            coins++; // Aumentar contador de monedas
                            coinsDisplay.textContent = coins;
                            // Eliminar del array para evitar volver a comprobar
                            currentLane.coins.splice(index, 1);
                        }
                    }
                });
            }

            // Colisiones con obstáculos en carriles de asfalto o hierba
            if (currentLane.type === 'road' || currentLane.type === 'grass') {
                currentLane.obstacles.forEach(obs => {
                    const obsRect = {
                        x: obs.x,
                        y: currentLane.y * TILE_SIZE, // Los obstáculos están en este carril
                        width: obs.width,
                        height: TILE_SIZE
                    };
                    // Comprobación de colisión AABB
                    if (playerRect.x < obsRect.x + obsRect.width &&
                        playerRect.x + playerRect.width > obsRect.x &&
                        playerRect.y === obsRect.y) { // Misma fila
                        setGameOver(); // Terminar el juego si hay colisión
                    }
                });
            }
        }

        /**
         * Establece el estado del juego a "terminado" y muestra el mensaje de fin de juego.
         */
        function setGameOver() {
            gameOver = true;
            gameStarted = false;
            cancelAnimationFrame(gameLoopId); // Detener el bucle del juego
            
            const finalScore = score + (2 * coins);
            finalScoreDisplay.textContent = finalScore;

            // Cambiar la condición de victoria a 200 puntos
            if (finalScore >= 200) { 
                gameOverText.textContent = "¡GANASTE!\n\nToma una captura a esta pantalla o déjala abierta y acércate a nuestro stand.";
                gameOverText.style.whiteSpace = 'pre-line'; // Para que el \n funcione
            } else {
                gameOverText.textContent = "¡Perdiste!";
                gameOverText.style.whiteSpace = 'normal';
            }

            gameOverMessage.style.display = 'block'; // Mostrar el mensaje de fin de juego
        }

        /**
         * El bucle principal del juego, que se ejecuta en cada frame de animación.
         */
        function gameLoop() {
            if (gameOver || !gameStarted) return;
            moveObstacles(); // Mover los obstáculos
            checkCollisions(); // Comprobar colisiones
            gameLoopId = requestAnimationFrame(gameLoop); // Solicitar el siguiente frame
        }

        /**
         * Reinicia el juego a su estado inicial.
         */
        function resetGame() {
            playerPos = { x: Math.floor(GAME_WIDTH_TILES / 2), y: 1 }; // Posición inicial del jugador
            score = 0; // Reiniciar puntuación
            coins = 0; // Reiniciar monedas
            currentMaxY = playerPos.y; // Reiniciar la fila más lejana alcanzada
            gameOver = false; // El juego no ha terminado
            
            scoreDisplay.textContent = score; // Actualizar marcador
            coinsDisplay.textContent = coins; // Actualizar monedas
            gameOverMessage.style.display = 'none'; // Ocultar mensaje de fin de juego
            
            initLanes(); // Regenerar todas las filas
            updatePlayerPosition(); // Restablecer la posición visual del jugador

            // Reiniciar el desplazamiento de la pantalla
            const scrollOffset = 0;
            lanes.forEach(lane => {
                lane.element.style.transform = `translateY(${scrollOffset}px)`;
            });
            player.style.transform = `translateY(${scrollOffset}px)`;

            gameStarted = true; // El juego ha comenzado
            gameLoop(); // Iniciar el bucle del juego
        }

        // --- Lógica de Control Táctil ---
        let touchStartX = 0;
        let touchStartY = 0;
        const SWIPE_THRESHOLD = 30; // Mínima distancia para considerar un deslizamiento

        gameContainer.addEventListener('touchstart', (e) => {
            // Prevenir el desplazamiento de la página al tocar el contenedor del juego
            e.preventDefault(); 
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, { passive: false }); // Usar { passive: false } para permitir preventDefault

        gameContainer.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevenir el desplazamiento de la página durante el deslizamiento
        }, { passive: false });

        gameContainer.addEventListener('touchend', (e) => {
            if (gameOver || !gameStarted) return;

            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;

            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;

            // Determinar si es un deslizamiento horizontal o vertical
            if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > SWIPE_THRESHOLD) {
                // Deslizamiento horizontal
                if (dx > 0) {
                    movePlayer(1, 0); // Deslizar a la derecha
                } else {
                    movePlayer(-1, 0); // Deslizar a la izquierda
                }
            } else if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > SWIPE_THRESHOLD) {
                // Deslizamiento vertical
                if (dy < 0) { // Deslizar hacia arriba (Y disminuye)
                    movePlayer(0, 1); // Mover hacia adelante
                }
                // No hay movimiento hacia abajo en este juego
            }
        });
        // --- Fin Lógica de Control Táctil ---


        // Añadir listeners de eventos
        restartButton.addEventListener('click', resetGame); // Botón de reinicio
        startButton.addEventListener('click', () => {
            console.log('1. Botón JUGAR presionado.'); // <-- Debug
            startScreen.style.display = 'none';
            console.log('2. startScreen display seteado a none.'); // <-- Debug
            resetGame(); // Start the game
            console.log('3. Función resetGame llamada.'); // <-- Debug
        });

        // Control de movimiento del jugador con las teclas de flecha (para PC)
        document.addEventListener('keydown', (e) => {
            if (!gameStarted && e.key !== "Escape") return;
            if (gameOver) return;

            switch (e.key) {
                case 'ArrowUp':
                    movePlayer(0, 1); // Mover hacia arriba
                    break;
                case 'ArrowDown':
                    // movePlayer(0, -1); // Deshabilitado el movimiento hacia abajo
                    break;
                case 'ArrowLeft':
                    movePlayer(-1, 0); // Mover hacia la izquierda
                    break;
                case 'ArrowRight':
                    movePlayer(1, 0); // Mover hacia la derecha
                    break;
            }
        });

        // Configuración inicial al cargar la página
        playerPos = { x: Math.floor(GAME_WIDTH_TILES / 2), y: 1 }; // Posición inicial del jugador
        initLanes(); // Inicializar las filas
        updatePlayerPosition(); // Actualizar posición del jugador
    </script>
</body>
</html>
