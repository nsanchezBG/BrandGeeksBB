<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Burger Run</title>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-K2W98TT7');</script>
    <!-- End Google Tag Manager -->
    
    <!-- Importar la fuente VT323 de Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">

    <!-- PWA: Enlace al archivo manifest.json -->
    <link rel="manifest" href="manifest.json">
    <!-- PWA: Colores para la barra de estado del navegador en Android -->
    <meta name="theme-color" content="#000000"> <!-- Cambiado a negro para mejor contraste con icono blanco -->

    <style>
        /* Estilos generales del cuerpo */
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Evita barras de desplazamiento */
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #ffffff; /* Fondo blanco */
            font-family: 'VT323', monospace; /* Fuente principal del juego */
        }
        /* Nuevo contenedor para escalar todo el juego y la UI */
        #main-game-wrapper {
            /* Dimensiones base "ideales" para el escalado */
            width: 400px; 
            /* Altura total ideal: 600px (juego) + 15px (margen controles) + 36px (controles) + 15px (margen marcador) + 110px (marcador) = ~771px */
            height: 771px; /* Altura calculada para contener todo */
            display: flex;
            flex-direction: column;
            align-items: center; /* Centrar los elementos internos */
            justify-content: flex-start; /* Alinear arriba para el contenido del juego */

            /* Aplicar el escalado a todo el wrapper */
            /* Centrado utilizando margin: auto; dentro de un body flex */
            margin: auto; 
            transform: scale(min(1, calc(100vw / 400), calc(100vh / 771)));
            transform-origin: center center; /* Asegurar que el escalado y traslación sean desde el centro */
            box-sizing: border-box; /* Asegurar que el padding se incluya en el tamaño */
        }

        /* Contenedor principal del juego (ahora con dimensiones fijas dentro del wrapper) */
        #game-container {
            width: 400px; /* 10 tiles de ancho */
            height: 600px; /* 15 tiles de alto */
            background-color: #ffffff; /* Color de fondo blanco para las filas */
            position: relative;
            overflow: hidden;
            border: 2px solid #333;
            /* box-shadow: 0 0 10px rgba(0,0,0,0.5); ELIMINADO: Sombra exterior del contenedor del juego */
            /* Asegurar que el contenedor del juego prevenga acciones táctiles */
            touch-action: none; 
            /* Por defecto, no recibe eventos de puntero hasta que el juego inicia */
            pointer-events: none; 
        }
        /* Estilo para cada carril (fila) */
        .lane {
            width: 100%;
            height: 40px; /* TILE_SIZE - se ajustará por JS */
            position: absolute;
            left: 0;
            display: flex;
            align-items: center;
            background-color: #ffffff; /* Todas las filas son blancas */
        }
        /* Estilo para el jugador */
        #player {
            width: 36px; /* Se ajustará por JS */
            height: 36px; /* Se ajustará por JS */
            position: absolute;
            transition: left 0.1s linear, top 0.1s linear;
            z-index: 10;
            box-sizing: border-box;
            /* PNG del jugador - RUTA RELATIVA. Se establecerá dinámicamente por JS */
            background-image: url('player.png'); 
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        /* Estilo para los obstáculos */
        .obstacle {
            height: 36px; /* Se ajustará por JS */
            position: absolute;
            border: 2px solid #000000; /* Borde negro */
            box-sizing: border-box;
            background-color: #000000; /* Obstáculos negros */
            z-index: 5; /* Asegura que los obstáculos se muestren sobre el carril */
        }
        /* Estilo para las monedas */
        .coin {
            width: 20px; /* Se ajustará por JS */
            height: 20px; /* Se ajustará por JS */
            position: absolute;
            z-index: 5;
            /* PNG de la moneda - RUTA RELATIVA */
            background-image: url('hamburger_411275.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        /* Marcador de puntuación */
        #score-board {
            /* Anchura fija, se escalará con el wrapper */
            width: 400px; /* Coincide con el ancho del game-container */
            
            margin-top: 10px; /* Margen superior y centrado automático */
            font-size: 24px; /* Tamaño base para los números */
            color: #000000; /* Texto negro para contraste */
            font-family: 'VT323', monospace; /* Aplicar fuente */
            display: flex; /* Usar flexbox para alinear elementos */
            justify-content: center; /* Centrar los elementos del marcador */
            align-items: center; /* Alinear verticalmente */
            padding: 5px 0;
            gap: 10px; /* Espaciado entre elementos */
        }
        #score-board .score-item {
            display: flex;
            flex-direction: column; /* Apilar texto y número */
            align-items: center; /* Centrar horizontalmente */
            text-align: center; /* Asegurar centrado del texto */
            gap: 0px; /* Eliminar espacio entre texto y número */
        }
        #score-board .score-text {
            font-size: 24px; /* TAMAÑO ACTUALIZADO: Igual que el número */
            line-height: 1; /* Ajustar altura de línea para compactar */
        }
        #score-board .score-number {
            font-size: 24px; /* Mantener tamaño para el número */
            line-height: 1; /* Ajustar altura de línea para compactar */
        }
        #score-board img {
            width: auto; /* Ancho automático para mantener proporción */
            height: 50px; /* Altura del logo para ocupar 2 líneas de texto, ajustar si es necesario */
            margin: 0 10px; /* Pequeño margen a los lados del logo */
        }
        /* Mensaje de fin de juego */
        #game-over-message {
            position: fixed; /* Posicionamiento fijo para cubrir toda la ventana */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex; /* Usar flexbox para centrar contenido */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 20px;
            z-index: 100;
            display: none; /* Oculto por defecto */
            pointer-events: auto; /* Asegura que reciba clics cuando está visible */
            padding: 20px; /* Añadir padding para evitar que el texto toque los bordes */
            box-sizing: border-box;
        }
        #game-over-message h2 { /* Título GAME OVER */
            font-size: 48px; /* Tamaño grande para GAME OVER */
            margin-top: 0;
            margin-bottom: 20px;
            text-shadow: 3px 3px #000;
        }
        #game-over-message p {
            font-size: 32px; /* Texto más grande */
            margin: 0; /* Eliminar márgenes por defecto de p */
            text-shadow: 2px 2px #000;
            line-height: 1.2; /* Ajustar para espaciado entre líneas */
        }
        #game-over-message .spacer { /* Espaciador para líneas vacías */
            height: 1em; /* Altura de una línea de texto */
            width: 100%; /* Asegurar que ocupe espacio */
        }
        /* Eliminados player-info-name y player-info-dni de la pantalla final */
        /* Eliminados camera-image y win-message-text de la pantalla final */

        #game-over-message button {
            padding: 15px 30px; /* Botón más grande */
            font-size: 24px; /* Texto del botón más grande */
            margin-top: 20px; /* Espacio antes del botón Reiniciar */
            cursor: pointer;
            background-color: #ffffff; /* Botón blanco */
            color: #000000; /* Texto negro */
            border: 2px solid #000000;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0,0,0,0.3); /* Ajuste de sombra */
            transition: all 0.2s ease;
            font-family: 'VT323', monospace; /* Aplicar fuente */
        }
        #game-over-message button:hover {
            background-color: #e0e0e0;
            box-shadow: 0 0 7px rgba(0,0,0,0.4);
        }
        /* Estilo para la sección del Leaderboard */
        #leaderboard-section {
            margin-top: 20px;
            width: 100%;
            max-width: 350px; /* Ancho para el leaderboard */
            color: white;
            font-family: 'VT323', monospace;
            text-align: center;
            border: 2px solid white;
            padding: 10px;
            box-sizing: border-box;
            background-color: rgba(0,0,0,0.5);
        }
        #leaderboard-section h3 {
            font-size: 28px;
            margin-top: 0;
            margin-bottom: 10px;
            text-shadow: 1px 1px #000;
        }
        #leaderboard-list {
            display: grid;
            grid-template-columns: 1fr 1fr; /* Dos columnas */
            gap: 5px 10px; /* Espacio entre filas y columnas */
            font-size: 24px;
            list-style: none; /* Eliminar viñetas */
            padding: 0;
            margin: 0;
        }
        #leaderboard-list li {
            text-align: center;
            white-space: nowrap; /* Evitar que el texto se rompa */
            overflow: hidden; /* Ocultar el desbordamiento */
            text-overflow: ellipsis; /* Mostrar puntos suspensivos si se desborda */
        }
        #leaderboard-list li.leaderboard-name { /* Nombres en la columna izquierda */
            text-align: right;
        }
        #leaderboard-list li.leaderboard-score { /* Puntajes en la columna derecha */
            text-align: left;
        }

        /* Pantalla de inicio */
        #start-screen {
            position: fixed; /* Posicionamiento fijo para cubrir toda la ventana */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #ffffff; /* Pantalla completamente blanca */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #000000; /* Texto negro */
            z-index: 1000;
            text-align: center;
            padding: 0 20px; /* Márgenes a izquierda y derecha para el contenido */
            box-sizing: border-box; /* Incluir padding en el ancho total */
            pointer-events: auto; /* Asegura que la pantalla de inicio reciba clics */
        }
        #start-screen-logo-h1 { /* Clase para la imagen del logo en h1 */
            width: 150px; /* Ajustado al ancho del logo superior */
            height: auto;
            margin-bottom: 10px; /* Espacio debajo de la imagen */
            display: block; /* Para centrar con margin: auto */
        }
        #start-screen h1 { 
            font-size: 36px; /* Más pequeño que 40px */
            margin-top: 0px; /* Ajustado para acercar al logo */
            margin-bottom: 10px; 
            /* text-shadow: 2px 2px #000; ELIMINADO: Sombra del texto Burger Run */
            font-family: 'VT323', monospace; /* Aplicar fuente */
            color: #000000; /* Asegurar color negro */
        }
        #start-screen #burger-run-title-logo { /* Estilo para la imagen del título */
            width: 150px; /* Ancho igual al logo de Burgerboy */
            height: auto;
            margin-top: 0px; /* Acercar al logo superior */
            margin-bottom: 10px; /* Espacio debajo */
        }
        #start-screen p { 
            font-size: 16px; /* Más pequeño que 18px */
            margin-bottom: 5px; /* Ajustar margen inferior para las nuevas líneas */
            font-family: 'VT323', monospace; /* Aplicar fuente */
            color: #000000; /* Asegurar color negro */
        }
        #start-screen #disclaimer-text {
            font-size: 10px; /* Letras muy pequeñas */
            margin-top: 15px; /* Espacio para separar del botón JUGAR */
            margin-bottom: 0px;
            line-height: 1.3;
            max-width: 300px; /* Limitar ancho para que no se extienda demasiado */
        }
        .input-group {
            margin-top: 15px; /* Espacio después de los textos de puntuación */
            margin-bottom: 5px; /* Reducido para juntar los campos */
            width: 100%;
            max-width: 250px; /* Ancho máximo para los campos de entrada */
            text-align: center; /* Centrar el contenido del grupo de entrada */
        }
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 20px;
            font-family: 'VT323', monospace;
            color: #000000;
            text-align: center; /* Centrar el texto de la etiqueta */
        }
        .input-group input[type="text"] {
            width: 100%;
            padding: 10px;
            font-size: 18px;
            font-family: 'VT323', monospace;
            border: 2px solid #000000;
            background-color: #ffffff;
            color: #000000;
            box-sizing: border-box;
            border-radius: 5px;
            text-align: center; /* Centrar el texto dentro del input */
        }
        .required-asterisk {
            color: red;
            display: none; /* Oculto por defecto */
            font-size: 20px;
            margin-left: 5px;
            vertical-align: middle;
        }
        #validation-message {
            color: red;
            font-size: 16px;
            margin-bottom: 10px;
            font-family: 'VT323', monospace;
            display: none; /* Oculto por defecto */
        }
        #start-button {
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            background-color: #000000; /* Botón negro */
            color: white; /* Letra blanca */
            border: none;
            border-radius: 5px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
            font-family: 'VT323', monospace; /* Aplicar fuente */
            pointer-events: auto; /* ¡Asegura que el botón reciba clics! */
            touch-action: manipulation; /* Optimiza la respuesta táctil para el botón */
            margin-top: 20px; /* Aumentado para separar del DNI/CE */
        }
        #start-button:hover {
            background-color: #333333; /* Un poco más claro al pasar el ratón */
            box-shadow: 3px 3px 7px rgba(0,0,0,0.4);
        }
        /* Estilo para el nuevo logo de la pantalla de inicio */
        #start-screen-logo {
            width: 150px; /* Ajusta el tamaño del logo según sea necesario */
            height: auto;
            margin-bottom: 0px; /* Ajustado para acercar a h1 */
        }

        /* Estilos para los controles móviles en pantalla */
        #mobile-controls {
            display: flex;
            justify-content: center;
            gap: 20px; /* Espacio entre botones */
            /* Posicionamiento fuera del game-container, debajo de él */
            margin-top: 15px; /* Espacio entre el game-container y los controles */
            width: 400px; /* Ancho igual al contenedor del juego */
            padding: 8px 10px; /* Padding vertical reducido */
            box-sizing: border-box;
            z-index: 1; /* Por debajo de las pantallas de UI, pero visible */
            pointer-events: auto; /* Asegura que los controles reciban clics cuando están visibles */
            background-color: transparent; /* Fondo transparente */
            display: none; /* Se ocultan por defecto y se muestran solo cuando el juego inicia */
        }

        .control-button {
            background-color: #000000; /* Fondo negro */
            color: white;
            font-family: 'VT323', monospace;
            font-size: 20px; /* Tamaño de fuente ajustado */
            padding: 8px 25px; /* Padding ajustado */
            border: none;
            border-radius: 10px;
            cursor: pointer;
            /* box-shadow: 3px 3px 7px rgba(0,0,0,0.4); ELIMINADO: Sombra de los botones de dirección */
            transition: background-color 0.1s ease;
            user-select: none; /* Evita selección de texto al tocar */
            -webkit-user-select: none; /* Para iOS */
            touch-action: manipulation; /* Mejora la respuesta táctil */
            flex-grow: 1; /* Permite que los botones se expandan para llenar el espacio */
            max-width: 120px; /* Limitar el ancho de cada botón */
            text-align: center;
        }

        .control-button:active {
            background-color: #333333; /* Color al presionar */
            /* box-shadow: 1px 1px 3px rgba(0,0,0,0.4); ELIMINADO: Sombra al presionar */
        }
    </style>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K2W98TT7"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div id="start-screen">
        <img id="start-screen-logo" src="descarga%20(1).png" alt="Burger Logo">
        <img id="burger-run-title-logo" src="burger%20run%20logo.png" alt="Burger Run Logo">
        <p>Esquiva los obstáculos y come todas las burgers que puedas.<br>Avanzar una fila = 1 punto<br>Comer una burger = 2 puntos</p>
        <div class="spacer"></div> <!-- Línea vacía -->
        <p>¡CONSIGUE 150 PUNTOS Y GÁNATE MERCH EXCLUSIVA DE BURGERBOY!</p>
        
        <div class="input-group">
            <label for="playerName">NOMBRE:<span id="nameAsterisk" class="required-asterisk">*</span></label>
            <input type="text" id="playerName" required>
        </div>
        <div class="input-group">
            <label for="playerDNI">DNI / CE:<span id="dniAsterisk" class="required-asterisk">*</span></label>
            <input type="text" id="playerDNI" required>
        </div>
        <p id="validation-message">Por favor rellena los campos requeridos.</p>

        <button id="start-button">JUGAR</button>

        <p id="disclaimer-text">
            Promoción válida solo el 31 de mayo de 2025 durante el BURGERFEST. Participa en el juego “BURGER RUN” escaneando el QR en el stand de Burgerboy. Si alcanzas 150 puntos y presentas tu pantalla de “¡GANASTE!” con nombre y DNI/CE en el stand de Burgerboy, podrás reclamar 1 premio (merch oficial) sujeto a disponibilidad. Máximo 1 premio por persona. Requiere seguir a Burgerboy en todas sus redes.
        </p>
    </div>

    <div id="game-over-message">
        <h2>GAME OVER</h2> <!-- Título fijo GAME OVER -->
        <div class="spacer"></div> 
        <p>Tu puntaje final: <span id="final-score">0</span></p>
        <div class="spacer"></div> 
        <!-- Eliminados player-info-name y player-info-dni de la pantalla final -->
        <!-- Eliminados camera-image y win-message-text de la pantalla final -->
        <div id="leaderboard-section">
            <h3>MEJORES PUNTUACIONES</h3>
            <ul id="leaderboard-list">
                <!-- Los elementos del leaderboard se insertarán aquí por JavaScript -->
                <li>Cargando...</li> 
            </ul>
        </div>
        <button id="restart-button" disabled>Reiniciar</button> </div>

    <!-- Nuevo wrapper para escalar todo el juego y la UI -->
    <div id="main-game-wrapper">
        <div id="game-container">
            <div id="player"></div>
            </div>

        <div id="mobile-controls">
            <button id="left-button" class="control-button">←</button>
            <button id="up-button" class="control-button">↑</button>
            <button id="right-button" class="control-button">→</button>
        </div>

        <div id="score-board">
            <div class="score-item">
                <span class="score-text">Filas avanzadas:</span>
                <span id="score" class="score-number">0</span>
            </div>
            <img src="descarga%20(1).png" alt="Burger Logo Score">
            <div class="score-item">
                <span class="score-text">Burgers comidas:</span>
                <span id="coins" class="score-number">0</span>
            </div>
        </div>
    </div>


    <audio id="background-music" loop preload="auto">
        <source src="City%20Echoes.mp3" type="audio/mpeg">
    </audio>
    <audio id="spawn-sound" preload="auto">
        <source src="spawn.MP3" type="audio/mpeg">
    </audio>
    <audio id="coin-sound" preload="auto">
        <source src="beep.MP3" type="audio/mpeg">
    </audio>
    <audio id="lose-sound" preload="auto">
        <source src="lose.mp3" type="audio/mpeg">
    </audio>

    <script>
        // PWA: Registrar el Service Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // RUTA CORREGIDA PARA EL SERVICE WORKER
                // Importante: La ruta aquí debe ser relativa a la raíz del dominio de GitHub Pages.
                // Si tu repo es nsanchezbg.github.io/BrandGeeksBB/, entonces la raíz de tu PWA es /BrandGeeksBB/
                navigator.serviceWorker.register('/BrandGeeksBB/service-worker.js') 
                    .then(registration => {
                        console.log('Service Worker registrado con éxito:', registration);
                    })
                    .catch(error => {
                        console.log('Fallo el registro del Service Worker:', error);
                    });
            });
        }

        // --- INICIO: DECLARACIONES DE CONSTANTES Y VARIABLES GLOBALES (MOVIDAS AL PRINCIPIO) ---
        // Constantes del juego
        const TILE_SIZE = 40; // TILE_SIZE vuelve a ser fijo, ya que el escalado es global
        const GAME_WIDTH_TILES_ORIGINAL = 10; // Ancho original en baldosas (para cálculos de TILE_SIZE)
        const GAME_HEIGHT_TILES_ORIGINAL = 15; // Alto original en baldosas (para cálculos de TILE_SIZE)
        const TOTAL_LANES_BUFFER = 20; // Número total de filas generadas (incluye las fuera de pantalla)

        // Variables de estado del juego
        let playerPos = { x: 0, y: 0 }; // Posición del jugador en unidades de baldosa
        let score = 0; // Filas avanzadas
        let coins = 0; // Monedas recolectadas
        let lanes = []; // Array que almacena los datos de cada fila
        let gameOver = false; // Indica si el juego ha terminado
        let gameLoopId; // ID del frame de animación
        let currentMaxY = 0; // La fila más lejana alcanzada por el jugador
        let gameStarted = false; // Indica si el juego ha comenzado

        // Variables para almacenar la información del jugador
        let currentPlayerName = '';
        let currentPlayerDNI = '';

        // Parámetros de dificultad
        const INITIAL_SAFE_LANES = 5; // Número de filas iniciales seguras (hierba)
        const DIFFICULTY_INCREASE_INTERVAL = 20; // Intervalo de puntuación para aumentar la dificultad
        const MAX_OBSTACLE_SPEED = 4; // Velocidad máxima para los obstáculos
        const MIN_OBSTACLE_SPEED = 1; // Velocidad mínima para los obstáculos

        // Tipos de carriles permitidos (solo hierba y asfalto)
        const laneTypes = ['grass', 'road'];
        // Tipos de obstáculos (coches en asfalto, cuadrados en hierba)
        const obstacleTypes = {
            road: [{ type: 'car', width: 2 }], // Los coches tienen un ancho de 2 baldosas
            grass: [{ type: 'square_obstacle', width: 1 }] // Nuevo obstáculo para hierba: un cuadrado negro
        };

        // Variables y URLs para el parpadeo del jugador
        const playerEyesOpenURL = 'player.png'; // Asumiendo que esta es la imagen del jugador con ojos abiertos
        const playerEyesClosedURL = 'player-blink.png'; // URL de la imagen de parpadeo
        let isPlayerBlinking = false;
        let blinkTimer = 0;
        const BLINK_INTERVAL_MIN = 180; // Mínimo de frames entre parpadeos (ej. 3 segundos a 60 FPS)
        const BLINK_INTERVAL_MAX = 360; // Máximo de frames entre parpadeos (ej. 6 segundos)
        const BLINK_DURATION = 5; // Frames que los ojos permanecen cerrados (muy corto para un parpadeo)

        // Variables para el control de dirección del jugador
        let playerFacingDirection = 1; // 1 para izquierda (por defecto), -1 para derecha (reflejado)
        // --- FIN: DECLARACIONES DE CONSTANTES Y VARIABLES GLOBALES ---


        // Obtener referencias a los elementos del DOM
        let gameContainer;
        let player;
        let scoreDisplay;
        let coinsDisplay;
        let gameOverMessage;
        let finalScoreDisplay;
        let restartButton;
        let startScreen;
        let startButton;
        let gameOverText;
        let playerNameInput;
        let playerDNIInput;
        let validationMessage;
        let nameAsterisk;
        let dniAsterisk;
        let cameraImage;
        let winMessageText;
        let backgroundMusic;
        let spawnSound;
        let coinSound;
        let loseSound;
        let leaderboardSection;
        let leaderboardList;
        let mobileControls;
        let leftButton;
        let upButton;
        let rightButton;

        // --- INICIO: Configuración de Google Sheets / Apps Script ---
        // ¡TU URL DE APPS SCRIPT AQUÍ!
        const APPS_SCRIPT_WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbxUVG_I0HyMxd-c2Wr9BKVsOqjBVT8FdsjFaccUJp2GDcv6kMah4l30-gbLgO4Xi9aM/exec'; 
        // ¡TU ID DE GOOGLE SHEET AQUÍ!
        const SPREADSHEET_ID = '1VAU3X8HdUMwcH2T9-3bitYXvfBQ7oB6-oAxSlxV2ISA'; 
        // --- FIN: Configuración de Google Sheets / Apps Script ---

        /**
         * Envía el puntaje del jugador a Google Sheets a través de Google Apps Script.
         * @param {string} playerName - Nombre del jugador.
         * @param {string} playerDNI - DNI del jugador.
         * @param {number} finalScore - Puntaje final del jugador.
         */
        async function sendScoreToGoogleSheets(playerName, playerDNI, finalScore) {
            try {
                const response = await fetch(APPS_SCRIPT_WEB_APP_URL, {
                    method: 'POST',
                    mode: 'no-cors', // Necesario para evitar errores CORS en App Script simple
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        playerName: playerName,
                        playerDNI: playerDNI,
                        finalScore: finalScore
                    }),
                });
                // Dado que mode: 'no-cors' se usa, no podemos leer la respuesta real
                // pero la solicitud se envía.
                console.log('Datos enviados a Google Sheets (respuesta no verificable debido a no-cors).');
            } catch (error) {
                console.error('Error al enviar datos a Google Sheets:', error);
            }
        }

        /**
         * Obtiene las mejores puntuaciones de Google Sheets a través de Google Apps Script.
         */
        async function fetchLeaderboard() {
            if (!leaderboardList) {
                console.error("Leaderboard list element not found (fetchLeaderboard).");
                return;
            }
            leaderboardList.innerHTML = '<li>Cargando...</li>'; // Mostrar mensaje de carga
            try {
                const response = await fetch(APPS_SCRIPT_WEB_APP_URL, {
                    method: 'GET',
                    mode: 'cors' // 'cors' sí permite leer la respuesta
                });
                const scores = await response.json();
                displayLeaderboard(scores);
            } catch (error) {
                console.error('Error al obtener el leaderboard:', error);
                leaderboardList.innerHTML = '<li>Error al cargar el leaderboard.</li>';
            }
        }

        /**
         * Muestra las puntuaciones del leaderboard en la lista.
         * @param {Array<Object>} scores - Array de objetos con las puntuaciones (ej. [{Nombre: "...", Puntaje: ...}]).
         */
        function displayLeaderboard(scores) {
            if (!leaderboardList) { // Verificar si el elemento existe antes de manipularlo
                console.error("Leaderboard list element not found for displayLeaderboard.");
                return;
            }
            leaderboardList.innerHTML = ''; // Limpiar lista existente
            if (scores && scores.length > 0) {
                scores.forEach((scoreEntry, index) => {
                    const listItemName = document.createElement('li');
                    listItemName.classList.add('leaderboard-name');
                    // 'Nombre' y 'Puntaje' son los nombres de las propiedades esperadas del JSON de Apps Script
                    listItemName.textContent = `${index + 1}. ${scoreEntry.Nombre || 'Anónimo'}`; 
                    leaderboardList.appendChild(listItemName); 

                    const listItemScore = document.createElement('li');
                    listItemScore.classList.add('leaderboard-score');
                    listItemScore.textContent = scoreEntry.Puntaje || 0; 
                    leaderboardList.appendChild(listItemScore); 
                });
            } else {
                leaderboardList.innerHTML = '<li>No hay puntuaciones aún.</li>';
            }
        }


        /**
         * Calcula y aplica el tamaño dinámico de los tiles y elementos del juego.
         */
        function resizeGameElements() {
            // TILE_SIZE ya es una constante global fija de 40px
            // Esta función ahora solo asegura que los elementos del juego se posicionen correctamente
            // y que los elementos de UI externos ajusten su ancho para coincidir con el contenedor del juego.

            // Player
            if (player) {
                player.style.width = (TILE_SIZE * 0.9) + 'px'; // 90% del tile size
                player.style.height = (TILE_SIZE * 0.9) + 'px';
            }

            // Lanes
            document.querySelectorAll('.lane').forEach(laneElement => {
                if (laneElement) laneElement.style.height = TILE_SIZE + 'px';
            });

            // Obstacles
            document.querySelectorAll('.obstacle').forEach(obsElement => {
                if (obsElement) {
                    obsElement.style.width = (obsElement.dataset.originalWidth * TILE_SIZE - (TILE_SIZE * 0.1)) + 'px';
                    obsElement.style.height = (TILE_SIZE * 0.9) + 'px';
                }
            });

            // Coins
            document.querySelectorAll('.coin').forEach(coinElement => {
                if (coinElement) {
                    coinElement.style.width = (TILE_SIZE * 0.5) + 'px'; // 50% del tile size
                    coinElement.style.height = (TILE_SIZE * 0.5) + 'px';
                    // Reajustar la posición de la moneda para centrarla en el tile
                    coinElement.style.left = (parseFloat(coinElement.dataset.xTile) * TILE_SIZE + (TILE_SIZE - (TILE_SIZE * 0.5)) / 2) + 'px';
                    coinElement.style.top = ((TILE_SIZE - (TILE_SIZE * 0.5)) / 2) + 'px';
                }
            });
            
            // Re-posicionar el jugador con el nuevo TILE_SIZE (aunque TILE_SIZE es fijo, esto es buena práctica)
            updatePlayerPosition();

            // Ajustar el ancho de los elementos externos para que coincidan con el ancho del game-container (400px)
            const scoreBoardElement = document.getElementById('score-board');
            const mobileControlsElement = document.getElementById('mobile-controls');

            if (gameContainer && scoreBoardElement) {
                scoreBoardElement.style.width = gameContainer.offsetWidth + 'px'; // Usar el offsetWidth del gameContainer
            }
            if (gameContainer && mobileControlsElement) {
                mobileControlsElement.style.width = gameContainer.offsetWidth + 'px'; // Usar el offsetWidth del gameContainer
            }

            // Ajusta el tamaño de la fuente en el score-board y mobile-controls proporcionalmente
            if (scoreBoardElement) {
                scoreBoardElement.style.fontSize = (TILE_SIZE * 0.6) + 'px'; // Ajusta el tamaño de la fuente
                let scoreTextElement = scoreBoardElement.querySelector('.score-text');
                if (scoreTextElement) scoreTextElement.style.fontSize = (TILE_SIZE * 0.6) + 'px'; 
                let scoreNumberElement = scoreBoardElement.querySelector('.score-number');
                if (scoreNumberElement) scoreNumberElement.style.fontSize = (TILE_SIZE * 0.6) + 'px';
                let scoreBoardImg = scoreBoardElement.querySelector('img');
                if (scoreBoardImg) scoreBoardImg.style.height = (TILE_SIZE * 1.25) + 'px'; // Escala el logo
            }

            if (mobileControlsElement) {
                mobileControlsElement.querySelectorAll('.control-button').forEach(button => {
                    button.style.fontSize = (TILE_SIZE * 0.5) + 'px';
                    button.style.padding = (TILE_SIZE * 0.2) + 'px ' + (TILE_SIZE * 0.6) + 'px';
                    button.style.borderRadius = (TILE_SIZE * 0.25) + 'px';
                });
            }
        }


        /**
         * Crea un elemento de carril (div) y lo añade al contenedor del juego.
         * @param {string} type - Tipo de carril ('grass' o 'road').
         * @param {number} yPos - Posición Y del carril en unidades de baldosa.
         * @returns {HTMLElement} El elemento div del carril creado.
         */
        function createLaneElement(type, yPos) {
            const laneDiv = document.createElement('div');
            laneDiv.classList.add('lane', type);
            laneDiv.style.bottom = (yPos * TILE_SIZE) + 'px'; // Posicionar desde abajo
            laneDiv.style.height = TILE_SIZE + 'px'; // Asegurar altura correcta
            gameContainer.appendChild(laneDiv);
            return laneDiv;
        }

        /**
         * Crea un elemento de obstáculo (div) y lo añade al carril especificado.
         * @param {object} lane - Objeto del carril al que se añade el obstáculo.
         * @param {object} obsData - Datos del obstáculo (tipo, ancho).
         * @returns {HTMLElement} El elemento div del obstáculo creado.
         */
        function createObstacleElement(lane, obsData) {
            const obsDiv = document.createElement('div');
            obsDiv.classList.add('obstacle', obsData.type);
            obsDiv.style.width = (obsData.width * TILE_SIZE - (TILE_SIZE * 0.1)) + 'px'; // -10% del tile size para el borde/espacio
            obsDiv.style.height = (TILE_SIZE * 0.9) + 'px'; // 90% del tile size
            obsDiv.dataset.originalWidth = obsData.width; // Guardar para reajuste en resizeGameElements
            // El color del obstáculo se define en CSS como negro
            obsDiv.style.position = 'absolute'; // Los obstáculos se posicionan absolutamente dentro de su carril
            lane.element.appendChild(obsDiv); // Añadir al elemento DOM del carril
            return obsDiv;
        }
        
        /**
         * Crea un elemento de moneda (div) y lo añade al carril especificado.
         * @param {object} lane - Objeto del carril al que se añade la moneda.
         * @param {number} xPosTile - Posición X de la moneda en unidades de baldosa.
         * @returns {HTMLElement} El elemento div de la moneda creado.
         */
        function createCoinElement(lane, xPosTile) {
            const coinDiv = document.createElement('div');
            coinDiv.classList.add('coin');
            // Posición izquierda ajustada para centrar la imagen de la moneda (20x20px)
            coinDiv.style.left = (xPosTile * TILE_SIZE + (TILE_SIZE - (TILE_SIZE * 0.5)) / 2) + 'px'; // 50% del tile size
            coinDiv.style.top = ((TILE_SIZE - (TILE_SIZE * 0.5)) / 2) + 'px'; // Centrar verticalmente en el carril
            coinDiv.style.width = (TILE_SIZE * 0.5) + 'px';
            coinDiv.style.height = (TILE_SIZE * 0.5) + 'px';
            coinDiv.dataset.xTile = xPosTile; // Guardar la posición del tile para el reajuste
            lane.element.appendChild(coinDiv);
            return coinDiv;
        }

        /**
         * Genera los datos y el elemento DOM para una nueva fila del juego.
         * @param {number} yPos - Posición Y del carril en unidades de baldosa.
         * @returns {object} Objeto que contiene los datos del carril.
         */
        function generateLane(yPos) {
            let type;
            let currentDifficultyLevel = Math.floor(score / DIFFICULTY_INCREASE_INTERVAL);

            // Asegurar que las filas iniciales sean seguras (hierba)
            if (yPos < INITIAL_SAFE_LANES) {
                type = 'grass';
            } else {
                // Aumentar la probabilidad de carriles de asfalto a medida que aumenta la dificultad
                let randomValue = Math.random();
                if (currentDifficultyLevel === 0) { // Juego temprano, principalmente hierba
                    type = (randomValue < 0.8) ? 'grass' : 'road';
                } else if (currentDifficultyLevel === 1) { // Medio: 1-2 obstáculos
                    type = (randomValue < 0.5) ? 'grass' : 'road';
                } else { // Difícil: 2-3 obstáculos
                    type = laneTypes[Math.floor(Math.random() * laneTypes.length)];
                }
            }

            const laneElement = createLaneElement(type, yPos);
            // Calcular la velocidad de los obstáculos basada en la dificultad
            let newSpeed = MIN_OBSTACLE_SPEED + (MAX_OBSTACLE_SPEED - MIN_OBSTACLE_SPEED) * (currentDifficultyLevel / 10);
            newSpeed = Math.min(newSpeed, MAX_OBSTACLE_SPEED); // Asegurar que la velocidad no exceda el máximo

            // Asegurar que la velocidad sea diferente a la del carril anterior para mayor variedad
            if (yPos > 0 && lanes[yPos - 1]) {
                const prevLaneSpeed = lanes[yPos - 1].speed;
                while (newSpeed === prevLaneSpeed) {
                    newSpeed = MIN_OBSTACLE_SPEED + Math.random() * (MAX_OBSTACLE_SPEED - MIN_OBSTACLE_SPEED);
                    newSpeed = Math.min(newSpeed, MAX_OBSTACLE_SPEED);
                }
            }

            const laneData = {
                y: yPos,
                type: type,
                element: laneElement,
                obstacles: [],
                coins: [], // Array para objetos de moneda
                direction: (Math.random() < 0.5 ? 1 : -1), // Dirección del movimiento de obstáculos
                speed: newSpeed // Velocidad asignada
            };

            // Generación de obstáculos
            if (type === 'road') {
                let currentX = (laneData.direction === 1) ? -TILE_SIZE * 3 : GAME_WIDTH_TILES_ORIGINAL * TILE_SIZE; // Usar GAME_WIDTH_TILES_ORIGINAL
                let numObstacles = 0;

                // Ajustar el número de obstáculos según la dificultad
                if (currentDifficultyLevel === 0) { // Fácil: 0-1 obstáculos
                    numObstacles = Math.random() < 0.6 ? 0 : 1; // Mayor probabilidad de 0 obstáculos
                } else if (currentDifficultyLevel === 1) { // Medio: 1-2 obstáculos
                    numObstacles = Math.floor(Math.random() * 2) + 1;
                } else { // Difícil: 2-3 obstáculos
                    numObstacles = Math.floor(Math.random() * 2) + 2;
                }

                for (let i = 0; i < numObstacles; i++) {
                    const obsTemplate = obstacleTypes[type][Math.floor(Math.random() * obstacleTypes[type].length)];
                    const obsElement = createObstacleElement(laneData, obsTemplate);
                    
                    let obsXPos;
                    if (laneData.direction === 1) {
                        obsXPos = currentX;
                        currentX -= (obsTemplate.width + (2 + Math.random() * 3)) * TILE_SIZE; // Espaciado
                    } else {
                        obsXPos = currentX;
                        currentX += (obsTemplate.width + (2 + Math.random() * 3)) * TILE_SIZE; // Espaciado
                    }
                    
                    laneData.obstacles.push({
                        element: obsElement,
                        x: obsXPos, // Posición en píxeles para el movimiento
                        width: obsTemplate.width * TILE_SIZE,
                        type: obsTemplate.type,
                        initialX: obsXPos // Almacenar X inicial para reinicio
                    });
                    obsElement.style.left = obsXPos + 'px'; // Asegurar que la posición se aplique al elemento
                }
            } else if (type === 'grass') {
                // Añadir monedas a algunas filas de hierba
                if (Math.random() < 0.4) { // Aumentado a 40% de probabilidad
                    const MAX_COINS_TO_TRY_SPAWNING = 3; // Intentar generar hasta 3 burgers
                    const COIN_SPAWN_CHANCE_PER_SLOT = 0.6; // 60% de probabilidad para cada intento

                    let spawnedPositions = new Set(); // Para evitar burgers apiladas

                    for (let i = 0; i < MAX_COINS_TO_TRY_SPAWNING; i++) {
                        if (Math.random() < COIN_SPAWN_CHANCE_PER_SLOT) {
                            let coinXTile;
                            let attempts = 0;
                            // Intentar encontrar una posición única
                            do {
                                coinXTile = Math.floor(Math.random() * GAME_WIDTH_TILES_ORIGINAL); // Usar GAME_WIDTH_TILES_ORIGINAL
                                attempts++;
                            } while (spawnedPositions.has(coinXTile) && attempts < GAME_WIDTH_TILES_ORIGINAL * 2); // Evitar bucle infinito

                            if (!spawnedPositions.has(coinXTile)) {
                                const coinElement = createCoinElement(laneData, coinXTile);
                                laneData.coins.push({
                                    element: coinElement,
                                    x: coinXTile * TILE_SIZE, // Posición en píxeles para la colisión
                                    y: 0, // Relativo al carril
                                    collected: false
                                });
                                spawnedPositions.add(coinXTile);
                            }
                        }
                    }
                }

                // Añadir nuevo obstáculo cuadrado_negro en filas de hierba (máximo 1 por fila)
                if (Math.random() < 0.3) { // 30% de probabilidad de añadir un obstáculo cuadrado
                    const obsTemplate = obstacleTypes.grass[0]; // Solo hay un tipo de obstáculo para hierba
                    const obsElement = createObstacleElement(laneData, obsTemplate);
                    
                    // Posicionar el obstáculo cuadrado aleatoriamente en el carril de hierba
                    const obsXPos = Math.floor(Math.random() * (GAME_WIDTH_TILES_ORIGINAL - obsTemplate.width + 1)) * TILE_SIZE; // Usar GAME_WIDTH_TILES_ORIGINAL

                    laneData.obstacles.push({
                        element: obsElement,
                        x: obsXPos,
                        width: obsTemplate.width * TILE_SIZE,
                        type: obsTemplate.type,
                        initialX: obsXPos
                    });
                    obsElement.style.left = obsXPos + 'px'; // ¡Esta línea es la corrección clave!
                }
            }
            return laneData;
        }

        /**
         * Inicializa todas las filas del juego, eliminando las existentes y creando nuevas.
         */
        function initLanes() {
            lanes.forEach(lane => {
                if (lane.element) gameContainer.removeChild(lane.element);
            });
            lanes = [];
            for (let i = 0; i < TOTAL_LANES_BUFFER; i++) {
                lanes.push(generateLane(i));
            }
        }

        /**
         * Actualiza la posición visual del jugador en la pantalla.
         */
        function updatePlayerPosition() {
            player.style.left = (playerPos.x * TILE_SIZE) + 'px'; 
            player.style.bottom = (playerPos.y * TILE_SIZE) + 'px';
            // Combina la transformación de desplazamiento con la de escala para la dirección
            const scrollOffset = Math.max(0, (playerPos.y - Math.floor(GAME_HEIGHT_TILES_ORIGINAL / 2.5)) * TILE_SIZE); // Usar GAME_HEIGHT_TILES_ORIGINAL
            player.style.transform = `translateY(${scrollOffset}px) scaleX(${playerFacingDirection})`;
        }

        /**
         * Mueve al jugador en la dirección especificada.
         * @param {number} dx - Cambio en la posición X (en unidades de baldosa).
         * @param {number} dy - Cambio en la posición Y (en unidades de baldosa).
         */
        function movePlayer(dx, dy) {
            if (gameOver) return;

            const newX = playerPos.x + dx;
            const newY = playerPos.y + dy;

            // Actualiza la dirección visual del jugador si hay movimiento horizontal
            if (dx > 0) { // Moviendo a la derecha
                playerFacingDirection = -1; // Reflejar para que mire a la derecha
            } else if (dx < 0) { // Moviendo a la izquierda
                playerFacingDirection = 1; // Orientación normal para que mire a la izquierda
            }

            // Comprobaciones de límites
            if (newX < 0 || newX >= GAME_WIDTH_TILES_ORIGINAL) return; // Usar GAME_WIDTH_TILES_ORIGINAL
            if (newY < 0) return; // No se permite el movimiento hacia atrás

            playerPos.x = newX;
            playerPos.y = newY;
            
            if (dy > 0) { // Si el jugador se movió hacia adelante
                if (newY > currentMaxY) {
                    score++; // Aumentar la puntuación por fila avanzada
                    currentMaxY = newY;
                    scoreDisplay.textContent = score;

                    // Comprobar si se necesitan generar nuevas filas
                    if (lanes[lanes.length -1].y < playerPos.y + GAME_HEIGHT_TILES_ORIGINAL) { // Usar GAME_HEIGHT_TILES_ORIGINAL
                       addNewLaneAtTop();
                    }
                }
            }
            
            // Desplazamiento de la pantalla: Mover todo el contenido del contenedor del juego
            // La transformación de desplazamiento de las lanes es independiente de la del player
            const scrollOffset = Math.max(0, (playerPos.y - Math.floor(GAME_HEIGHT_TILES_ORIGINAL / 2.5)) * TILE_SIZE); // Usar GAME_HEIGHT_TILES_ORIGINAL
            lanes.forEach(lane => {
                lane.element.style.transform = `translateY(${scrollOffset}px)`;
            });
            // player.style.transform se actualiza en updatePlayerPosition()
            
            updatePlayerPosition(); // Actualización visual del jugador
            checkCollisions(); // Comprobar colisiones después del movimiento
        }
        
        /**
         * Añade una nueva fila en la parte superior del área de juego visible.
         */
        function addNewLaneAtTop() {
            const newLaneY = lanes[lanes.length - 1].y + 1;
            lanes.push(generateLane(newLaneY));

            // Opcional: Eliminar filas muy antiguas que están muy por debajo del jugador
            if (lanes.length > TOTAL_LANES_BUFFER + 5) {
                const oldLane = lanes.shift();
                if(oldLane.element.parentNode) {
                    gameContainer.removeChild(oldLane.element);
                }
            }
        }

        /**
         * Mueve los obstáculos en sus respectivos carriles.
         */
        function moveObstacles() {
            lanes.forEach(lane => {
                // Solo mover obstáculos en carriles de asfalto
                if (lane.type === 'road') {
                    lane.obstacles.forEach(obs => {
                        obs.x += lane.speed * lane.direction; 
                        // Reiniciar la posición del obstáculo si se sale de la pantalla
                        if (lane.direction === 1 && obs.x > GAME_WIDTH_TILES_ORIGINAL * TILE_SIZE) { // Usar GAME_WIDTH_TILES_ORIGINAL
                            obs.x = -obs.width; // Reiniciar a la izquierda
                        } else if (lane.direction === -1 && obs.x + obs.width < 0) {
                            obs.x = GAME_WIDTH_TILES_ORIGINAL * TILE_SIZE; // Reiniciar a la derecha // Usar GAME_WIDTH_TILES_ORIGINAL
                        }
                        obs.element.style.left = obs.x + 'px';
                    });
                }
                // Los obstáculos de tipo 'grass' (square_obstacle) son estáticos, no se mueven.
            });
        }

        /**
         * Comprueba las colisiones entre el jugador y los obstáculos o monedas.
         */
        function checkCollisions() {
            if (gameOver) return;
            const playerRect = {
                x: playerPos.x * TILE_SIZE,
                y: playerPos.y * TILE_SIZE, // Posición Y base del carril del jugador
                width: TILE_SIZE,
                height: TILE_SIZE
            };
            
            const currentLane = lanes.find(l => l.y === playerPos.y);
            if (!currentLane) {
                console.warn("El jugador está en un carril inexistente:", playerPos.y);
                setGameOver();
                return;
            }

            // Colección de monedas
            if (currentLane.type === 'grass' && currentLane.coins) {
                currentLane.coins.forEach((coin, index) => {
                    if (!coin.collected) {
                        const coinRect = {
                            x: coin.x + (TILE_SIZE - (TILE_SIZE * 0.5)) / 2, // X de la moneda es relativo al inicio del carril, ajustado para centrar
                            y: currentLane.y * TILE_SIZE + (TILE_SIZE - (TILE_SIZE * 0.5)) / 2, // Usar Y absoluto del carril, ajustado para centrar
                            width: (TILE_SIZE * 0.5), height: (TILE_SIZE * 0.5)
                        };
                         // Colisión AABB para la moneda
                        if (playerRect.x < coinRect.x + coinRect.width &&
                            playerRect.x + playerRect.width > coinRect.x &&
                            playerRect.y < coinRect.y + coinRect.height &&
                            playerRect.y + playerRect.height > coinRect.y) {
                            
                            coin.collected = true;
                            if(coin.element.parentNode) coin.element.parentNode.removeChild(coin.element); // Eliminar moneda visualmente
                            coins++; // Aumentar contador de monedas
                            coinsDisplay.textContent = coins;
                            // Eliminar del array para evitar volver a comprobar
                            currentLane.coins.splice(index, 1);
                            if (coinSound) { // Reproducir sonido de moneda
                                coinSound.currentTime = 0; // Reiniciar sonido
                                coinSound.play().catch(error => console.error("Error al reproducir sonido de moneda:", error));
                            }
                        }
                    }
                });
            }

            // Colisiones con obstáculos en carriles de asfalto o hierba
            if (currentLane.type === 'road' || currentLane.type === 'grass') {
                currentLane.obstacles.forEach(obs => {
                    const obsRect = {
                        x: obs.x,
                        y: currentLane.y * TILE_SIZE, // Los obstáculos están en este carril
                        width: obs.width,
                        height: TILE_SIZE
                    };
                    // Comprobación de colisión AABB
                    if (playerRect.x < obsRect.x + obsRect.width &&
                        playerRect.x + playerRect.width > obsRect.x &&
                        playerRect.y === obsRect.y) { // Misma fila
                        setGameOver(); // Terminar el juego si hay colisión
                    }
                });
            }
        }

        /**
         * Establece el estado del juego a "terminado" y muestra el mensaje de fin de juego.
         */
        async function setGameOver() { // Marcar como async para await fetchLeaderboard
            gameOver = true;
            gameStarted = false;
            cancelAnimationFrame(gameLoopId); // Detener el bucle del juego
            
            const finalScore = score + (2 * coins);
            if (finalScoreDisplay) finalScoreDisplay.textContent = finalScore;

            // Ocultar elementos específicos ya que no hay condición de ganar/perder específica
            if (playerInfoNameDisplay) playerInfoNameDisplay.style.display = 'none';
            if (playerInfoDNIDisplay) playerInfoDNIDisplay.style.display = 'none';
            if (cameraImage) cameraImage.style.display = 'none';
            if (winMessageText) winMessageText.style.display = 'none';

            // Siempre mostrar "GAME OVER"
            if (gameOverText) gameOverText.textContent = "GAME OVER"; 

            // Ocultar controles móviles
            if (mobileControls) mobileControls.style.display = 'none';
            // Deshabilitar interacción con el juego
            if (gameContainer) gameContainer.style.pointerEvents = 'none';

            // Reproducir sonido de fin de juego
            if (loseSound) {
                loseSound.currentTime = 0; // Reiniciar sonido
                loseSound.play().catch(error => console.error("Error al reproducir sonido de fin de juego:", error));
            }

            if (gameOverMessage) gameOverMessage.style.display = 'flex'; // Mostrar el mensaje de fin de juego
            
            // Enviar puntuación antes de obtener el leaderboard
            await sendScoreToGoogleSheets(currentPlayerName, currentPlayerDNI, finalScore);
            // Obtener y mostrar el leaderboard
            await fetchLeaderboard();

            // Habilitar el botón de reiniciar después de un breve retraso
            if (restartButton) restartButton.disabled = true; // Asegurarse de que esté deshabilitado al mostrar la pantalla
            setTimeout(() => {
                if (restartButton) restartButton.disabled = false; // Habilitar el botón después de 500ms
            }, 500); // Retraso de 0.5 segundos
        }

        /**
         * Función para actualizar la animación de parpadeo del jugador.
         */
        function updatePlayerBlinking() {
            if (gameOver || !gameStarted) {
                if (player) player.style.backgroundImage = `url('${playerEyesOpenURL}')`; // Asegurar ojos abiertos si el juego no está activo
                return;
            }

            if (!isPlayerBlinking) {
                blinkTimer--;
                if (blinkTimer <= 0) {
                    isPlayerBlinking = true;
                    blinkTimer = BLINK_DURATION; // Duración de los ojos cerrados
                    if (player) player.style.backgroundImage = `url('${playerEyesClosedURL}')`;
                }
            } else {
                blinkTimer--;
                if (blinkTimer <= 0) {
                    isPlayerBlinking = false;
                    // Intervalo aleatorio para el próximo parpadeo
                    blinkTimer = Math.floor(Math.random() * (BLINK_INTERVAL_MAX - BLINK_INTERVAL_MIN + 1)) + BLINK_INTERVAL_MIN;
                    if (player) player.style.backgroundImage = `url('${playerEyesOpenURL}')`;
                }
            }
        }

        /**
         * El bucle principal del juego, que se ejecuta en cada frame de animación.
         */
        function gameLoop() {
            if (gameOver || !gameStarted) return;
            moveObstacles(); // Mover los obstáculos
            checkCollisions(); // Comprobar colisiones
            updatePlayerBlinking(); // Actualizar la animación de parpadeo
            gameLoopId = requestAnimationFrame(gameLoop); // Solicitar el siguiente frame
        }

        /**
         * Reinicia el juego a su estado inicial.
         */
        function resetGame() {
            console.log('resetGame called'); // Log para depuración
            // Validar campos de nombre y DNI solo si se está iniciando desde la pantalla de inicio
            if (!gameStarted) { // Solo validar en el primer inicio, no en reinicios desde game over
                let isValid = true;
                // Ocultar mensajes de validación y asteriscos
                if (validationMessage) validationMessage.style.display = 'none';
                if (nameAsterisk) nameAsterisk.style.display = 'none';
                if (dniAsterisk) dniAsterisk.style.display = 'none';

                if (playerNameInput && !playerNameInput.value.trim()) {
                    if (nameAsterisk) nameAsterisk.style.display = 'inline';
                    isValid = false;
                }
                if (playerDNIInput && !playerDNIInput.value.trim()) {
                    if (dniAsterisk) dniAsterisk.style.display = 'inline';
                    isValid = false;
                }

                if (!isValid) {
                    if (validationMessage) validationMessage.style.display = 'block';
                    console.error('Validación fallida: Campos requeridos no rellenados.'); // Log de error para depuración
                    return; // No iniciar el juego si los campos están vacíos
                }
                if (playerNameInput) currentPlayerName = playerNameInput.value.trim();
                if (playerDNIInput) currentPlayerDNI = playerDNIInput.value.trim();
            }


            playerPos = { x: Math.floor(GAME_WIDTH_TILES_ORIGINAL / 2), y: 1 }; // Posición inicial del jugador
            score = 0; // Reiniciar puntuación
            coins = 0; // Reiniciar monedas
            currentMaxY = playerPos.y; // Reiniciar la fila más lejana alcanzada
            gameOver = false; // El juego no ha terminado
            
            if (scoreDisplay) scoreDisplay.textContent = score; // Actualizar marcador
            if (coinsDisplay) coinsDisplay.textContent = coins; // Actualizar monedas
            if (gameOverMessage) gameOverMessage.style.display = 'none'; // Ocultar mensaje de fin de juego
            
            initLanes(); // Regenerar todas las filas
            updatePlayerPosition(); // Restablecer la posición visual del jugador

            // Reset scroll
            const scrollOffset = 0;
            lanes.forEach(lane => {
                if (lane.element) lane.element.style.transform = `translateY(${scrollOffset}px)`;
            });
            // player.style.transform se actualiza en updatePlayerPosition()

            gameStarted = true; // El juego ha comenzado
            gameLoop(); // Iniciar el bucle del juego
            if (mobileControls) mobileControls.style.display = 'flex'; // Mostrar controles móviles al iniciar el juego
            if (gameContainer) gameContainer.style.pointerEvents = 'auto'; // Habilitar interacción con el juego
            if (startScreen) startScreen.style.display = 'none'; // Ocultar la pantalla de inicio

            // Reproducir música al iniciar el juego
            if (backgroundMusic) {
                backgroundMusic.play().catch(error => {
                    console.error("Error al intentar reproducir la música de fondo:", error);
                    // Esto puede ocurrir si el navegador bloquea la reproducción automática
                    // Podrías mostrar un mensaje al usuario para que toque la pantalla para activar el sonido
                });
            }
            // Reproducir sonido de spawn
            if (spawnSound) {
                spawnSound.currentTime = 0; // Reiniciar sonido
                spawnSound.play().catch(error => console.error("Error al reproducir sonido de spawn:", error));
            }

            // --- GTM: Enviar evento de inicio de ronda de juego ---
            if (typeof dataLayer !== 'undefined') {
                let currentEngagementType;
                // Si gameStarted es FALSE al principio de esta función, es el primer juego.
                // Si gameStarted es TRUE, es un reinicio.
                // La variable `gameStarted` se actualizará a `true` después de esta lógica,
                // así que `!gameStarted` aquí indica si es la *primera* vez que se llama desde la pantalla de inicio.
                if (!gameStarted) { 
                    currentEngagementType = 'initial_play';
                } else { 
                    currentEngagementType = 'restart_play';
                }
                
                dataLayer.push({
                    'event': 'game_round_start', // Nombre del evento
                    'engagement_type': currentEngagementType,
                    'player_name': currentPlayerName,
                    'player_dni': currentPlayerDNI
                });
            }
            // --- Fin GTM Evento ---
        }

        // --- Lógica de Control Táctil ---
        let touchStartX = 0;
        let touchStartY = 0;
        const SWIPE_THRESHOLD = 30; // Mínima distancia para considerar un deslizamiento

        // Estos listeners se adjuntan en DOMContentLoaded
        // Por lo tanto, las referencias a gameContainer, etc. deben ser variables declaradas arriba (let)
        // y asignadas dentro de DOMContentLoaded para evitar "Cannot read properties of undefined"
        // ya que al inicio del script son undefined
        // gameContainer.addEventListener('touchstart', (e) => { ... }); // MOVIDO A DOMContentLoaded

        // Envuelve los listeners en DOMContentLoaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOMContentLoaded fired.'); // Log para depuración
            // Asignar referencias a los elementos del DOM DENTRO de DOMContentLoaded
            gameContainer = document.getElementById('game-container');
            player = document.getElementById('player');
            scoreDisplay = document.getElementById('score');
            coinsDisplay = document.getElementById('coins');
            gameOverMessage = document.getElementById('game-over-message');
            finalScoreDisplay = document.getElementById('final-score');
            restartButton = document.getElementById('restart-button');
            startScreen = document.getElementById('start-screen');
            startButton = document.getElementById('start-button');
            gameOverText = document.getElementById('game-over-text');
            playerNameInput = document.getElementById('playerName');
            playerDNIInput = document.getElementById('playerDNI');
            validationMessage = document.getElementById('validation-message');
            nameAsterisk = document.getElementById('nameAsterisk');
            dniAsterisk = document.getElementById('dniAsterisk');
            cameraImage = document.getElementById('camera-image');
            winMessageText = document.getElementById('win-message-text');
            backgroundMusic = document.getElementById('background-music');
            spawnSound = document.getElementById('spawn-sound');
            coinSound = document.getElementById('coin-sound');
            loseSound = document.getElementById('lose-sound');
            leaderboardSection = document.getElementById('leaderboard-section');
            leaderboardList = document.getElementById('leaderboard-list');
            mobileControls = document.getElementById('mobile-controls');
            leftButton = document.getElementById('left-button');
            upButton = document.getElementById('up-button');
            rightButton = document.getElementById('right-button');
            
            // Precargar la imagen de parpadeo para evitar el efecto de "desaparición"
            const preloadBlinkImage = new Image();
            preloadBlinkImage.src = playerEyesClosedURL;

            // Llamar a resizeGameElements al inicio y en cada cambio de tamaño de ventana
            resizeGameElements();
            window.addEventListener('resize', resizeGameElements);

            // Añadir listeners de eventos
            restartButton.addEventListener('click', resetGame); // Botón de reinicio
            
            // El botón de inicio ahora valida los campos antes de iniciar el juego
            startButton.addEventListener('click', resetGame); 

            // Event listeners para los nuevos botones de control móvil
            // Estos listeners MOVIDOS DENTRO de DOMContentLoaded
            if (gameContainer) { // Verificar que gameContainer no sea null antes de adjuntar listeners de touch
                gameContainer.addEventListener('touchstart', (e) => {
                    // Prevenir el desplazamiento de la página al tocar el contenedor del juego
                    e.preventDefault(); 
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }, { passive: false }); // Usar { passive: false } para permitir preventDefault

                gameContainer.addEventListener('touchmove', (e) => {
                    e.preventDefault(); // Prevenir el desplazamiento de la página durante el deslizamiento
                }, { passive: false });

                gameContainer.addEventListener('touchend', (e) => {
                    if (gameOver || !gameStarted) return;

                    const touchEndX = e.changedTouches[0].clientX;
                    const touchEndY = e.changedTouches[0].clientY;

                    const dx = touchEndX - touchStartX;
                    const dy = touchEndY - touchStartY;

                    // Determinar si es un deslizamiento horizontal o vertical
                    if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > SWIPE_THRESHOLD) {
                        // Deslizamiento horizontal
                        if (dx > 0) {
                            movePlayer(1, 0); // Deslizar a la derecha
                        } else {
                            movePlayer(-1, 0); // Deslizar a la izquierda
                        }
                    } else if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > SWIPE_THRESHOLD) { 
                        // Deslizamiento vertical
                        if (dy < 0) { // Deslizar hacia arriba (Y disminuye)
                            movePlayer(0, 1); // Mover hacia adelante
                        }
                        // No hay movimiento hacia abajo en este juego
                    }
                });
            }
            // --- Fin Lógica de Control Táctil ---


            // Event listeners para los nuevos botones de control móvil
            if (leftButton) {
                leftButton.addEventListener('click', () => {
                    if (gameStarted && !gameOver) {
                        movePlayer(-1, 0);
                    }
                });
            }
            if (upButton) {
                upButton.addEventListener('click', () => {
                    if (gameStarted && !gameOver) {
                        movePlayer(0, 1);
                    }
                });
            }
            if (rightButton) {
                rightButton.addEventListener('click', () => {
                    if (gameStarted && !gameOver) {
                        movePlayer(1, 0);
                    }
                });
            }

            // Control de movimiento del jugador con las teclas de flecha (para PC)
            document.addEventListener('keydown', (e) => {
                if (!gameStarted && e.key !== "Escape") return;
                if (gameOver) return;

                switch (e.key) {
                    case 'ArrowUp':
                        movePlayer(0, 1); // Mover hacia arriba
                        break;
                    case 'ArrowDown':
                        // movePlayer(0, -1); // Deshabilitado el movimiento hacia abajo
                        break;
                    case 'ArrowLeft':
                        movePlayer(-1, 0); // Mover hacia la izquierda
                        break;
                    case 'ArrowRight':
                        movePlayer(1, 0); // Mover hacia la derecha
                        break;
                }
            });

            // Configuración inicial al cargar la página
            playerPos = { x: Math.floor(GAME_WIDTH_TILES_ORIGINAL / 2), y: 1 }; // Posición inicial del jugador
            initLanes(); // Inicializar las filas
            updatePlayerPosition(); // Actualizar posición del jugador
            // Inicializar el temporizador de parpadeo al cargar la página
            blinkTimer = Math.floor(Math.random() * (BLINK_INTERVAL_MAX - BLINK_INTERVAL_MIN + 1)) + BLINK_INTERVAL_MIN;
        });
    </script>
</body>
</html>
