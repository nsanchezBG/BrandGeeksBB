<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Burger Run</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        /* Estilos generales del cuerpo */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #ffffff; /* Fondo blanco */
            font-family: 'VT323', monospace; /* Fuente principal del juego */
            overflow: hidden; /* Evita barras de desplazamiento en el área de juego */
        }
        /* Contenedor principal del juego */
        #game-container {
            width: 400px; /* 10 tiles de ancho */
            height: 600px; /* 15 tiles de alto */
            background-color: #ffffff; /* Color de fondo blanco para las filas */
            position: relative;
            overflow: hidden;
            border: 2px solid #333;
            /* box-shadow: 0 0 10px rgba(0,0,0,0.5); ELIMINADO: Sombra exterior del contenedor del juego */
            /* Asegurar que el contenedor del juego prevenga acciones táctiles */
            touch-action: none; 
            /* Por defecto, no recibe eventos de puntero hasta que el juego inicia */
            pointer-events: none; 
        }
        /* Estilo para cada carril (fila) */
        .lane {
            width: 100%;
            height: 40px; /* TILE_SIZE */
            position: absolute;
            left: 0;
            display: flex;
            align-items: center;
            background-color: #ffffff; /* Todas las filas son blancas */
        }
        /* Estilo para el jugador */
        #player {
            width: 36px; /* Ligeramente más pequeño que TILE_SIZE para espacio visual */
            height: 36px;
            position: absolute;
            transition: left 0.1s linear, top 0.1s linear;
            z-index: 10;
            box-sizing: border-box;
            /* PNG del jugador */
            background-image: url('https://i.ibb.co/jP49jhv1/player.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        /* Estilo para los obstáculos */
        .obstacle {
            height: 36px; /* Altura consistente con el tamaño del tile */
            position: absolute;
            border: 2px solid #000000; /* Borde negro */
            box-sizing: border-box;
            background-color: #000000; /* Obstáculos negros */
            z-index: 5; /* Asegura que los obstáculos se muestren sobre el carril */
        }
        /* Estilo para las monedas */
        .coin {
            width: 20px; /* Tamaño ajustado para la imagen de la moneda */
            height: 20px; /* Tamaño ajustado para la imagen de la moneda */
            position: absolute;
            z-index: 5;
            /* PNG de la moneda */
            background-image: url('https://i.ibb.co/bjW4KsPS/hamburger-411275.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        /* Marcador de puntuación */
        #score-board {
            margin-top: 10px;
            font-size: 24px; /* Tamaño base para los números */
            color: #000000; /* Texto negro para contraste */
            font-family: 'VT323', monospace; /* Aplicar fuente */
            display: flex; /* Usar flexbox para alinear elementos */
            justify-content: space-around; /* Espacio equitativo entre elementos */
            align-items: center; /* Alinear verticalmente */
            width: 400px; /* Ancho igual al contenedor del juego */
            padding: 5px 0;
        }
        #score-board .score-item {
            display: flex;
            flex-direction: column; /* Apilar texto y número */
            align-items: center; /* Centrar horizontalmente */
            text-align: center; /* Asegurar centrado del texto */
            gap: 0px; /* Eliminar espacio entre texto y número */
        }
        #score-board .score-text {
            font-size: 18px; /* Tamaño más pequeño para el texto */
            line-height: 1; /* Ajustar altura de línea para compactar */
        }
        #score-board .score-number {
            font-size: 24px; /* Mantener tamaño para el número */
            line-height: 1; /* Ajustar altura de línea para compactar */
        }
        #score-board img {
            width: auto; /* Ancho automático para mantener proporción */
            height: 50px; /* Altura del logo para ocupar 2 líneas de texto, ajustar si es necesario */
            margin: 0 10px; /* Pequeño margen a los lados del logo */
        }
        /* Mensaje de fin de juego */
        #game-over-message {
            position: fixed; /* Posicionamiento fijo para cubrir toda la ventana */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex; /* Usar flexbox para centrar contenido */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 20px;
            z-index: 100;
            display: none; /* Oculto por defecto */
            pointer-events: auto; /* Asegura que reciba clics cuando está visible */
            padding: 20px; /* Añadir padding para evitar que el texto toque los bordes */
            box-sizing: border-box;
        }
        #game-over-message p {
            font-size: 32px; /* Texto más grande */
            margin: 0; /* Eliminar márgenes por defecto de p */
            text-shadow: 2px 2px #000;
            line-height: 1.2; /* Ajustar para espaciado entre líneas */
        }
        #game-over-message .spacer { /* Espaciador para líneas vacías */
            height: 1em; /* Altura de una línea de texto */
            width: 100%; /* Asegurar que ocupe espacio */
        }
        #game-over-message #player-info-name,
        #game-over-message #player-info-dni {
            font-size: 32px; /* Mismo tamaño que el texto principal */
            margin: 0; /* Controlar espaciado con .spacer */
        }
        #game-over-message #camera-image {
            width: 75px; /* Mitad del ancho del botón Reiniciar */
            height: auto;
            margin: 15px auto; /* Centrar y dar margen */
            display: block; /* Asegurar que se muestre como bloque para centrar */
        }
        #game-over-message #win-message-text {
            font-size: 32px; /* Mismo tamaño que el texto principal */
            margin-top: 0; /* Controlar espaciado con .spacer o margen de imagen */
            margin-bottom: 20px; /* Espacio antes del botón Reiniciar */
        }
        #game-over-message button {
            padding: 15px 30px; /* Botón más grande */
            font-size: 24px; /* Texto del botón más grande */
            margin-top: 0; /* Ya hay margen en el texto de arriba */
            cursor: pointer;
            background-color: #ffffff; /* Botón blanco */
            color: #000000; /* Texto negro */
            border: 2px solid #000000;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0,0,0,0.3); /* Ajuste de sombra */
            transition: all 0.2s ease;
            font-family: 'VT323', monospace; /* Aplicar fuente */
        }
        #game-over-message button:hover {
            background-color: #e0e0e0;
            box-shadow: 0 0 7px rgba(0,0,0,0.4);
        }
        /* Pantalla de inicio */
        #start-screen {
            position: fixed; /* Posicionamiento fijo para cubrir toda la ventana */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #ffffff; /* Pantalla completamente blanca */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #000000; /* Texto negro */
            z-index: 1000;
            text-align: center;
            padding: 0 20px; /* Márgenes a izquierda y derecha para el contenido */
            box-sizing: border-box; /* Incluir padding en el ancho total */
            pointer-events: auto; /* Asegura que la pantalla de inicio reciba clics */
        }
        #start-screen h1 { 
            font-size: 36px; /* Más pequeño que 40px */
            margin-top: 0px; /* Ajustado para acercar al logo */
            margin-bottom: 10px; 
            text-shadow: 2px 2px #000;
            font-family: 'VT323', monospace; /* Aplicar fuente */
            color: #000000; /* Asegurar color negro */
        }
        #start-screen p { 
            font-size: 16px; /* Más pequeño que 18px */
            margin-bottom: 5px; /* Ajustar margen inferior para las nuevas líneas */
            font-family: 'VT323', monospace; /* Aplicar fuente */
            color: #000000; /* Asegurar color negro */
        }
        .input-group {
            margin-top: 15px; /* Espacio después de los textos de puntuación */
            margin-bottom: 5px; /* Reducido para juntar los campos */
            width: 100%;
            max-width: 250px; /* Ancho máximo para los campos de entrada */
            text-align: center; /* Centrar el contenido del grupo de entrada */
        }
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 20px;
            font-family: 'VT323', monospace;
            color: #000000;
            text-align: center; /* Centrar el texto de la etiqueta */
        }
        .input-group input[type="text"] {
            width: 100%;
            padding: 10px;
            font-size: 18px;
            font-family: 'VT323', monospace;
            border: 2px solid #000000;
            background-color: #ffffff;
            color: #000000;
            box-sizing: border-box;
            border-radius: 5px;
            text-align: center; /* Centrar el texto dentro del input */
        }
        .required-asterisk {
            color: red;
            display: none; /* Oculto por defecto */
            font-size: 20px;
            margin-left: 5px;
            vertical-align: middle;
        }
        #validation-message {
            color: red;
            font-size: 16px;
            margin-bottom: 10px;
            font-family: 'VT323', monospace;
            display: none; /* Oculto por defecto */
        }
        #start-button {
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            background-color: #000000; /* Botón negro */
            color: white; /* Letra blanca */
            border: none;
            border-radius: 5px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
            font-family: 'VT323', monospace; /* Aplicar fuente */
            pointer-events: auto; /* ¡Asegura que el botón reciba clics! */
            touch-action: manipulation; /* Optimiza la respuesta táctil para el botón */
            margin-top: 20px; /* Aumentado para separar del DNI/CE */
        }
        #start-button:hover {
            background-color: #333333; /* Un poco más claro al pasar el ratón */
            box-shadow: 3px 3px 7px rgba(0,0,0,0.4);
        }
        /* Estilo para el nuevo logo de la pantalla de inicio */
        #start-screen-logo {
            width: 150px; /* Ajusta el tamaño del logo según sea necesario */
            height: auto;
            margin-bottom: 0px; /* Ajustado para acercar a h1 */
        }

        /* Estilos para los controles móviles en pantalla */
        #mobile-controls {
            display: flex;
            justify-content: center;
            gap: 20px; /* Espacio entre botones */
            /* Posicionamiento fuera del game-container, debajo de él */
            margin-top: 15px; /* Espacio entre el game-container y los controles */
            width: 400px; /* Ancho igual al contenedor del juego */
            padding: 8px 10px; /* Padding vertical reducido */
            box-sizing: border-box;
            z-index: 1; /* Por debajo de las pantallas de UI, pero visible */
            pointer-events: auto; /* Asegura que los controles reciban clics cuando están visibles */
            background-color: transparent; /* Fondo transparente */
            display: none; /* Se ocultan por defecto y se muestran solo cuando el juego inicia */
        }

        .control-button {
            background-color: #000000; /* Fondo negro */
            color: white;
            font-family: 'VT323', monospace;
            font-size: 20px; /* Tamaño de fuente ajustado */
            padding: 8px 25px; /* Padding ajustado */
            border: none;
            border-radius: 10px;
            cursor: pointer;
            /* box-shadow: 3px 3px 7px rgba(0,0,0,0.4); ELIMINADO: Sombra de los botones de dirección */
            transition: background-color 0.1s ease;
            user-select: none; /* Evita selección de texto al tocar */
            -webkit-user-select: none; /* Para iOS */
            touch-action: manipulation; /* Mejora la respuesta táctil */
            flex-grow: 1; /* Permite que los botones se expandan para llenar el espacio */
            max-width: 120px; /* Limitar el ancho de cada botón */
            text-align: center;
        }

        .control-button:active {
            background-color: #333333; /* Color al presionar */
            /* box-shadow: 1px 1px 3px rgba(0,0,0,0.4); ELIMINADO: Sombra al presionar */
        }
    </style>
</head>
<body>
    <div id="start-screen">
        <img id="start-screen-logo" src="https://i.ibb.co/rKdjZkM8/descarga-1.png" alt="Burger Logo">
        <h1>BURGER RUN</h1>
        <p>Esquiva los obstáculos y come todas las burgers que puedas.</p>
        <p>Avanzar una fila = 1 punto<br>Comer una burger = 2 puntos</p>
        <div class="spacer"></div> <p>¡CONSIGUE 150 PUNTOS Y GÁNATE MERCH EXCLUSIVA DE BURGERBOY!</p>
        
        <div class="input-group">
            <label for="playerName">NOMBRE:<span id="nameAsterisk" class="required-asterisk">*</span></label>
            <input type="text" id="playerName" required>
        </div>
        <div class="input-group">
            <label for="playerDNI">DNI / CE:<span id="dniAsterisk" class="required-asterisk">*</span></label>
            <input type="text" id="playerDNI" required>
        </div>
        <p id="validation-message">Por favor rellena los campos requeridos.</p>

        <button id="start-button">JUGAR</button>
    </div>

    <div id="game-over-message">
        <p id="game-over-text"></p> 
        <div class="spacer"></div> 
        <p>Tu puntaje final: <span id="final-score">0</span></p>
        <div class="spacer"></div> 
        <p>NOMBRE:</p>
        <p id="player-info-name"></p> 
        <p>DNI / CE:</p>
        <p id="player-info-dni"></p>   
        <div class="spacer"></div> 
        <img id="camera-image" src="https://i.ibb.co/Lhkk99D5/camera.png" alt="Camera Icon">
        <p id="win-message-text"></p> 
        <button id="restart-button" disabled>Reiniciar</button> </div>

    <div id="game-container">
        <div id="player"></div>
        </div>

    <div id="mobile-controls">
        <button id="left-button" class="control-button">←</button>
        <button id="up-button" class="control-button">↑</button>
        <button id="right-button" class="control-button">→</button>
    </div>

    <div id="score-board">
        <div class="score-item">
            <span class="score-text">Filas avanzadas:</span>
            <span id="score" class="score-number">0</span>
        </div>
        <img src="https://i.ibb.co/rKdjZkM8/descarga-1.png" alt="Burger Logo Score">
        <div class="score-item">
            <span class="score-text">Burgers comidas:</span>
            <span id="coins" class="score-number">0</span>
        </div>
    </div>

    <audio id="background-music" loop preload="auto">
        <source src="https://nsanchezbg.github.io/BrandGeeksBB/City%20Echoes.mp3" type="audio/mpeg">
        Tu navegador no soporta el elemento de audio.
    </audio>

    <script>
        // Obtener referencias a los elementos del DOM
        const gameContainer = document.getElementById('game-container');
        const player = document.getElementById('player');
        const scoreDisplay = document.getElementById('score');
        const coinsDisplay = document.getElementById('coins');
        const gameOverMessage = document.getElementById('game-over-message');
        const finalScoreDisplay = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const gameOverText = document.getElementById('game-over-text'); // Nuevo elemento para el texto de game over
        const playerNameInput = document.getElementById('playerName'); // Campo de nombre
        const playerDNIInput = document.getElementById('playerDNI');   // Campo de DNI
        const playerInfoNameDisplay = document.getElementById('player-info-name'); // Div para mostrar nombre del jugador
        const playerInfoDNIDisplay = document.getElementById('player-info-dni');   // Div para mostrar DNI del jugador
        const validationMessage = document.getElementById('validation-message'); // Mensaje de validación
        const nameAsterisk = document.getElementById('nameAsterisk'); // Asterisco de nombre
        const dniAsterisk = document.getElementById('dniAsterisk');     // Asterisco de DNI
        const cameraImage = document.getElementById('camera-image'); // Imagen de la cámara
        const winMessageText = document.getElementById('win-message-text'); // Texto de "Toma una captura..."
        const backgroundMusic = document.getElementById('background-music'); // Elemento de audio

        // Controles móviles
        const leftButton = document.getElementById('left-button');
        const upButton = document.getElementById('up-button');
        const rightButton = document.getElementById('right-button');
        const mobileControls = document.getElementById('mobile-controls'); // Referencia a los controles móviles


        // Constantes del juego
        const TILE_SIZE = 40; // Tamaño de cada "baldosa" o celda
        const GAME_WIDTH_TILES = 10; // Ancho del juego en número de baldosas
        const GAME_HEIGHT_TILES = 15; // Filas visibles en pantalla
        const TOTAL_LANES_BUFFER = 20; // Número total de filas generadas (incluye las fuera de pantalla)

        // Variables de estado del juego
        let playerPos = { x: 0, y: 0 }; // Posición del jugador en unidades de baldosa
        let score = 0; // Filas avanzadas
        let coins = 0; // Monedas recolectadas
        let lanes = []; // Array que almacena los datos de cada fila
        let gameOver = false; // Indica si el juego ha terminado
        let gameLoopId; // ID del frame de animación
        let currentMaxY = 0; // La fila más lejana alcanzada por el jugador
        let gameStarted = false; // Indica si el juego ha comenzado

        // Variables para almacenar la información del jugador
        let currentPlayerName = '';
        let currentPlayerDNI = '';

        // Parámetros de dificultad
        const INITIAL_SAFE_LANES = 5; // Número de filas iniciales seguras (hierba)
        const DIFFICULTY_INCREASE_INTERVAL = 20; // Intervalo de puntuación para aumentar la dificultad
        const MAX_OBSTACLE_SPEED = 4; // Velocidad máxima para los obstáculos
        const MIN_OBSTACLE_SPEED = 1; // Velocidad mínima para los obstáculos

        // Tipos de carriles permitidos (solo hierba y asfalto)
        const laneTypes = ['grass', 'road'];
        // Tipos de obstáculos (coches en asfalto, cuadrados en hierba)
        const obstacleTypes = {
            road: [{ type: 'car', width: 2 }], // Los coches tienen un ancho de 2 baldosas
            grass: [{ type: 'square_obstacle', width: 1 }] // Nuevo obstáculo para hierba: un cuadrado negro
        };

        /**
         * Crea un elemento de carril (div) y lo añade al contenedor del juego.
         * @param {string} type - Tipo de carril ('grass' o 'road').
         * @param {number} yPos - Posición Y del carril en unidades de baldosa.
         * @returns {HTMLElement} El elemento div del carril creado.
         */
        function createLaneElement(type, yPos) {
            const laneDiv = document.createElement('div');
            laneDiv.classList.add('lane', type);
            laneDiv.style.bottom = (yPos * TILE_SIZE) + 'px'; // Posicionar desde abajo
            gameContainer.appendChild(laneDiv);
            return laneDiv;
        }

        /**
         * Crea un elemento de obstáculo (div) y lo añade al carril especificado.
         * @param {object} lane - Objeto del carril al que se añade el obstáculo.
         * @param {object} obsData - Datos del obstáculo (tipo, ancho).
         * @returns {HTMLElement} El elemento div del obstáculo creado.
         */
        function createObstacleElement(lane, obsData) {
            const obsDiv = document.createElement('div');
            obsDiv.classList.add('obstacle', obsData.type);
            obsDiv.style.width = (obsData.width * TILE_SIZE - 4) + 'px'; // -4 para el borde
            // El color del obstáculo se define en CSS como negro
            obsDiv.style.position = 'absolute'; // Los obstáculos se posicionan absolutamente dentro de su carril
            lane.element.appendChild(obsDiv); // Añadir al elemento DOM del carril
            return obsDiv;
        }
        
        /**
         * Crea un elemento de moneda (div) y lo añade al carril especificado.
         * @param {object} lane - Objeto del carril al que se añade la moneda.
         * @param {number} xPosTile - Posición X de la moneda en unidades de baldosa.
         * @returns {HTMLElement} El elemento div de la moneda creado.
         */
        function createCoinElement(lane, xPosTile) {
            const coinDiv = document.createElement('div');
            coinDiv.classList.add('coin');
            // Posición izquierda ajustada para centrar la imagen de la moneda (20x20px)
            coinDiv.style.left = (xPosTile * TILE_SIZE + (TILE_SIZE - 20) / 2) + 'px';
            coinDiv.style.top = ((TILE_SIZE - 20) / 2) + 'px'; // Centrar verticalmente en el carril
            lane.element.appendChild(coinDiv);
            return coinDiv;
        }

        /**
         * Genera los datos y el elemento DOM para una nueva fila del juego.
         * @param {number} yPos - Posición Y del carril en unidades de baldosa.
         * @returns {object} Objeto que contiene los datos del carril.
         */
        function generateLane(yPos) {
            let type;
            let currentDifficultyLevel = Math.floor(score / DIFFICULTY_INCREASE_INTERVAL);

            // Asegurar que las filas iniciales sean seguras (hierba)
            if (yPos < INITIAL_SAFE_LANES) {
                type = 'grass';
            } else {
                // Aumentar la probabilidad de carriles de asfalto a medida que aumenta la dificultad
                let randomValue = Math.random();
                if (currentDifficultyLevel === 0) { // Juego temprano, principalmente hierba
                    type = (randomValue < 0.8) ? 'grass' : 'road';
                } else if (currentDifficultyLevel === 1) { // Dificultad media
                    type = (randomValue < 0.5) ? 'grass' : 'road';
                } else { // Dificultad alta, más variedad
                    type = laneTypes[Math.floor(Math.random() * laneTypes.length)];
                }
            }

            const laneElement = createLaneElement(type, yPos);
            // Calcular la velocidad de los obstáculos basada en la dificultad
            let newSpeed = MIN_OBSTACLE_SPEED + (MAX_OBSTACLE_SPEED - MIN_OBSTACLE_SPEED) * (currentDifficultyLevel / 10);
            newSpeed = Math.min(newSpeed, MAX_OBSTACLE_SPEED); // Asegurar que la velocidad no exceda el máximo

            // Asegurar que la velocidad sea diferente a la del carril anterior para mayor variedad
            if (yPos > 0 && lanes[yPos - 1]) {
                const prevLaneSpeed = lanes[yPos - 1].speed;
                while (newSpeed === prevLaneSpeed) {
                    newSpeed = MIN_OBSTACLE_SPEED + Math.random() * (MAX_OBSTACLE_SPEED - MIN_OBSTACLE_SPEED);
                    newSpeed = Math.min(newSpeed, MAX_OBSTACLE_SPEED);
                }
            }

            const laneData = {
                y: yPos,
                type: type,
                element: laneElement,
                obstacles: [],
                coins: [], // Array para objetos de moneda
                direction: (Math.random() < 0.5 ? 1 : -1), // Dirección del movimiento de obstáculos
                speed: newSpeed // Velocidad asignada
            };

            // Generación de obstáculos
            if (type === 'road') {
                let currentX = (laneData.direction === 1) ? -TILE_SIZE * 3 : GAME_WIDTH_TILES * TILE_SIZE;
                let numObstacles = 0;

                // Ajustar el número de obstáculos según la dificultad
                if (currentDifficultyLevel === 0) { // Fácil: 0-1 obstáculos
                    numObstacles = Math.random() < 0.6 ? 0 : 1; // Mayor probabilidad de 0 obstáculos
                } else if (currentDifficultyLevel === 1) { // Medio: 1-2 obstáculos
                    numObstacles = Math.floor(Math.random() * 2) + 1;
                } else { // Difícil: 2-3 obstáculos
                    numObstacles = Math.floor(Math.random() * 2) + 2;
                }

                for (let i = 0; i < numObstacles; i++) {
                    const obsTemplate = obstacleTypes[type][Math.floor(Math.random() * obstacleTypes[type].length)];
                    const obsElement = createObstacleElement(laneData, obsTemplate);
                    
                    let obsXPos;
                    if (laneData.direction === 1) {
                        obsXPos = currentX;
                        currentX -= (obsTemplate.width + (2 + Math.random() * 3)) * TILE_SIZE; // Espaciado
                    } else {
                        obsXPos = currentX;
                        currentX += (obsTemplate.width + (2 + Math.random() * 3)) * TILE_SIZE; // Espaciado
                    }
                    
                    laneData.obstacles.push({
                        element: obsElement,
                        x: obsXPos, // Posición en píxeles para el movimiento
                        width: obsTemplate.width * TILE_SIZE,
                        type: obsTemplate.type,
                        initialX: obsXPos // Almacenar X inicial para reinicio
                    });
                    obsElement.style.left = obsXPos + 'px'; // Asegurar que la posición se aplique al elemento
                }
            } else if (type === 'grass') {
                // Añadir monedas a algunas filas de hierba
                if (Math.random() < 0.4) { // Aumentado a 40% de probabilidad
                    const MAX_COINS_TO_TRY_SPAWNING = 3; // Intentar generar hasta 3 burgers
                    const COIN_SPAWN_CHANCE_PER_SLOT = 0.6; // 60% de probabilidad para cada intento

                    let spawnedPositions = new Set(); // Para evitar burgers apiladas

                    for (let i = 0; i < MAX_COINS_TO_TRY_SPAWNING; i++) {
                        if (Math.random() < COIN_SPAWN_CHANCE_PER_SLOT) {
                            let coinXTile;
                            let attempts = 0;
                            // Intentar encontrar una posición única
                            do {
                                coinXTile = Math.floor(Math.random() * GAME_WIDTH_TILES);
                                attempts++;
                            } while (spawnedPositions.has(coinXTile) && attempts < GAME_WIDTH_TILES * 2); // Evitar bucle infinito

                            if (!spawnedPositions.has(coinXTile)) {
                                const coinElement = createCoinElement(laneData, coinXTile);
                                laneData.coins.push({
                                    element: coinElement,
                                    x: coinXTile * TILE_SIZE, // Posición en píxeles para la colisión
                                    y: 0, // Relativo al carril
                                    collected: false
                                });
                                spawnedPositions.add(coinXTile);
                            }
                        }
                    }
                }

                // Añadir nuevo obstáculo cuadrado_negro en filas de hierba (máximo 1 por fila)
                if (Math.random() < 0.3) { // 30% de probabilidad de añadir un obstáculo cuadrado
                    const obsTemplate = obstacleTypes.grass[0]; // Solo hay un tipo de obstáculo para hierba
                    const obsElement = createObstacleElement(laneData, obsTemplate);
                    
                    // Posicionar el obstáculo cuadrado aleatoriamente en el carril de hierba
                    const obsXPos = Math.floor(Math.random() * (GAME_WIDTH_TILES - obsTemplate.width + 1)) * TILE_SIZE;

                    laneData.obstacles.push({
                        element: obsElement,
                        x: obsXPos,
                        width: obsTemplate.width * TILE_SIZE,
                        type: obsTemplate.type,
                        initialX: obsXPos
                    });
                    obsElement.style.left = obsXPos + 'px'; // ¡Esta línea es la corrección clave!
                }
            }
            return laneData;
        }

        /**
         * Inicializa todas las filas del juego, eliminando las existentes y creando nuevas.
         */
        function initLanes() {
            lanes.forEach(lane => {
                if (lane.element) gameContainer.removeChild(lane.element);
            });
            lanes = [];
            for (let i = 0; i < TOTAL_LANES_BUFFER; i++) {
                lanes.push(generateLane(i));
            }
        }

        /**
         * Actualiza la posición visual del jugador en la pantalla.
         */
        function updatePlayerPosition() {
            player.style.left = (playerPos.x * TILE_SIZE) + 'px'; 
            player.style.bottom = (playerPos.y * TILE_SIZE) + 'px';
        }

        /**
         * Mueve al jugador en la dirección especificada.
         * @param {number} dx - Cambio en la posición X (en unidades de baldosa).
         * @param {number} dy - Cambio en la posición Y (en unidades de baldosa).
         */
        function movePlayer(dx, dy) {
            if (gameOver) return;

            const newX = playerPos.x + dx;
            const newY = playerPos.y + dy;

            // Comprobaciones de límites
            if (newX < 0 || newX >= GAME_WIDTH_TILES) return;
            if (newY < 0) return; // No se permite el movimiento hacia atrás

            playerPos.x = newX;
            playerPos.y = newY;
            
            if (dy > 0) { // Si el jugador se movió hacia adelante
                if (newY > currentMaxY) {
                    score++; // Aumentar la puntuación por fila avanzada
                    currentMaxY = newY;
                    scoreDisplay.textContent = score;

                    // Comprobar si se necesitan generar nuevas filas
                    if (lanes[lanes.length -1].y < playerPos.y + GAME_HEIGHT_TILES) {
                       addNewLaneAtTop();
                    }
                }
            }
            
            // Desplazamiento de la pantalla: Mover todo el contenido del contenedor del juego
            const scrollOffset = Math.max(0, (playerPos.y - Math.floor(GAME_HEIGHT_TILES / 2.5)) * TILE_SIZE);
            lanes.forEach(lane => {
                lane.element.style.transform = `translateY(${scrollOffset}px)`;
            });
            player.style.transform = `translateY(${scrollOffset}px)`;

            updatePlayerPosition(); // Actualización visual del jugador
            checkCollisions(); // Comprobar colisiones después del movimiento
        }
        
        /**
         * Añade una nueva fila en la parte superior del área de juego visible.
         */
        function addNewLaneAtTop() {
            const newLaneY = lanes[lanes.length - 1].y + 1;
            lanes.push(generateLane(newLaneY));

            // Opcional: Eliminar filas muy antiguas que están muy por debajo del jugador
            if (lanes.length > TOTAL_LANES_BUFFER + 5) {
                const oldLane = lanes.shift();
                if(oldLane.element.parentNode) {
                    gameContainer.removeChild(oldLane.element);
                }
            }
        }

        /**
         * Mueve los obstáculos en sus respectivos carriles.
         */
        function moveObstacles() {
            lanes.forEach(lane => {
                // Solo mover obstáculos en carriles de asfalto
                if (lane.type === 'road') {
                    lane.obstacles.forEach(obs => {
                        obs.x += lane.speed * lane.direction; 
                        // Reiniciar la posición del obstáculo si se sale de la pantalla
                        if (lane.direction === 1 && obs.x > GAME_WIDTH_TILES * TILE_SIZE) {
                            obs.x = -obs.width; // Reiniciar a la izquierda
                        } else if (lane.direction === -1 && obs.x + obs.width < 0) {
                            obs.x = GAME_WIDTH_TILES * TILE_SIZE; // Reiniciar a la derecha
                        }
                        obs.element.style.left = obs.x + 'px';
                    });
                }
                // Los obstáculos de tipo 'grass' (square_obstacle) son estáticos, no se mueven.
            });
        }

        /**
         * Comprueba las colisiones entre el jugador y los obstáculos o monedas.
         */
        function checkCollisions() {
            if (gameOver) return;
            const playerRect = {
                x: playerPos.x * TILE_SIZE,
                y: playerPos.y * TILE_SIZE, // Posición Y base del carril del jugador
                width: TILE_SIZE,
                height: TILE_SIZE
            };
            
            const currentLane = lanes.find(l => l.y === playerPos.y);
            if (!currentLane) {
                console.warn("El jugador está en un carril inexistente:", playerPos.y);
                setGameOver();
                return;
            }

            // Colección de monedas
            if (currentLane.type === 'grass' && currentLane.coins) {
                currentLane.coins.forEach((coin, index) => {
                    if (!coin.collected) {
                        const coinRect = {
                            x: coin.x + (TILE_SIZE - 20) / 2, // X de la moneda es relativo al inicio del carril, ajustado para centrar
                            y: currentLane.y * TILE_SIZE + (TILE_SIZE - 20) / 2, // Usar Y absoluto del carril, ajustado para centrar
                            width: 20, height: 20
                        };
                         // Colisión AABB para la moneda
                        if (playerRect.x < coinRect.x + coinRect.width &&
                            playerRect.x + playerRect.width > coinRect.x &&
                            playerRect.y < coinRect.y + coinRect.height &&
                            playerRect.y + playerRect.height > coinRect.y) {
                            
                            coin.collected = true;
                            if(coin.element.parentNode) coin.element.parentNode.removeChild(coin.element); // Eliminar moneda visualmente
                            coins++; // Aumentar contador de monedas
                            coinsDisplay.textContent = coins;
                            // Eliminar del array para evitar volver a comprobar
                            currentLane.coins.splice(index, 1);
                        }
                    }
                });
            }

            // Colisiones con obstáculos en carriles de asfalto o hierba
            if (currentLane.type === 'road' || currentLane.type === 'grass') {
                currentLane.obstacles.forEach(obs => {
                    const obsRect = {
                        x: obs.x,
                        y: currentLane.y * TILE_SIZE, // Los obstáculos están en este carril
                        width: obs.width,
                        height: TILE_SIZE
                    };
                    // Comprobación de colisión AABB
                    if (playerRect.x < obsRect.x + obsRect.width &&
                        playerRect.x + playerRect.width > obsRect.x &&
                        playerRect.y === obsRect.y) { // Misma fila
                        setGameOver(); // Terminar el juego si hay colisión
                    }
                });
            }
        }

        /**
         * Establece el estado del juego a "terminado" y muestra el mensaje de fin de juego.
         */
        function setGameOver() {
            gameOver = true;
            gameStarted = false;
            cancelAnimationFrame(gameLoopId); // Detener el bucle del juego
            
            const finalScore = score + (2 * coins);
            finalScoreDisplay.textContent = finalScore;

            // Mostrar información del jugador
            playerInfoNameDisplay.textContent = currentPlayerName;
            playerInfoDNIDisplay.textContent = currentPlayerDNI;

            // Ocultar controles móviles
            mobileControls.style.display = 'none';
            // Deshabilitar interacción con el juego
            gameContainer.style.pointerEvents = 'none';

            // Cambiar la condición de victoria a 150 puntos
            if (finalScore >= 150) { 
                gameOverText.textContent = "¡GANASTE!";
                winMessageText.textContent = "Toma una captura a esta pantalla o déjala abierta y acércate a nuestro stand.";
                winMessageText.style.display = 'block'; // Mostrar texto de "Toma una captura..."
                cameraImage.style.display = 'block'; // Mostrar imagen de cámara si ganó
            } else {
                gameOverText.textContent = "¡Perdiste!";
                winMessageText.style.display = 'none'; // Ocultar texto de "Toma una captura..."
                cameraImage.style.display = 'none'; // Ocultar imagen de cámara si perdió
            }

            gameOverMessage.style.display = 'flex'; // Mostrar el mensaje de fin de juego (ahora con display: flex)
            
            // Habilitar el botón de reiniciar después de un breve retraso
            restartButton.disabled = true; // Asegurarse de que esté deshabilitado al mostrar la pantalla
            setTimeout(() => {
                restartButton.disabled = false; // Habilitar el botón después de 500ms
            }, 500); // Retraso de 0.5 segundos
        }

        /**
         * El bucle principal del juego, que se ejecuta en cada frame de animación.
         */
        function gameLoop() {
            if (gameOver || !gameStarted) return;
            moveObstacles(); // Mover los obstáculos
            checkCollisions(); // Comprobar colisiones
            gameLoopId = requestAnimationFrame(gameLoop); // Solicitar el siguiente frame
        }

        /**
         * Reinicia el juego a su estado inicial.
         */
        function resetGame() {
            // Validar campos de nombre y DNI solo si se está iniciando desde la pantalla de inicio
            if (!gameStarted) { // Solo validar en el primer inicio, no en reinicios desde game over
                let isValid = true;
                // Ocultar mensajes de validación y asteriscos
                validationMessage.style.display = 'none';
                nameAsterisk.style.display = 'none';
                dniAsterisk.style.display = 'none';

                if (!playerNameInput.value.trim()) {
                    nameAsterisk.style.display = 'inline';
                    isValid = false;
                }
                if (!playerDNIInput.value.trim()) {
                    dniAsterisk.style.display = 'inline';
                    isValid = false;
                }

                if (!isValid) {
                    validationMessage.style.display = 'block';
                    return; // No iniciar el juego si los campos están vacíos
                }
                currentPlayerName = playerNameInput.value.trim();
                currentPlayerDNI = playerDNIInput.value.trim();
            }


            playerPos = { x: Math.floor(GAME_WIDTH_TILES / 2), y: 1 }; // Posición inicial del jugador
            score = 0; // Reiniciar puntuación
            coins = 0; // Reiniciar monedas
            currentMaxY = playerPos.y; // Reiniciar la fila más lejana alcanzada
            gameOver = false; // El juego no ha terminado
            
            scoreDisplay.textContent = score; // Actualizar marcador
            coinsDisplay.textContent = coins; // Actualizar monedas
            gameOverMessage.style.display = 'none'; // Ocultar mensaje de fin de juego
            
            initLanes(); // Regenerar todas las filas
            updatePlayerPosition(); // Restablecer la posición visual del jugador

            // Reset scroll
            const scrollOffset = 0;
            lanes.forEach(lane => {
                lane.element.style.transform = `translateY(${scrollOffset}px)`;
            });
            player.style.transform = `translateY(${scrollOffset}px)`;

            gameStarted = true; // El juego ha comenzado
            gameLoop(); // Iniciar el bucle del juego
            mobileControls.style.display = 'flex'; // Mostrar controles móviles al iniciar el juego
            gameContainer.style.pointerEvents = 'auto'; // Habilitar interacción con el juego
            startScreen.style.display = 'none'; // Ocultar la pantalla de inicio

            // Reproducir música al iniciar el juego
            if (backgroundMusic) {
                backgroundMusic.play().catch(error => {
                    console.error("Error al intentar reproducir la música:", error);
                    // Esto puede ocurrir si el navegador bloquea la reproducción automática
                    // Podrías mostrar un mensaje al usuario para que toque la pantalla para activar el sonido
                });
            }
        }

        // --- Lógica de Control Táctil ---
        let touchStartX = 0;
        let touchStartY = 0;
        const SWIPE_THRESHOLD = 30; // Mínima distancia para considerar un deslizamiento

        // Ahora los listeners de touch están en gameContainer, que es el área de juego
        gameContainer.addEventListener('touchstart', (e) => {
            // Prevenir el desplazamiento de la página al tocar el contenedor del juego
            e.preventDefault(); 
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, { passive: false }); // Usar { passive: false } para permitir preventDefault

        gameContainer.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevenir el desplazamiento de la página durante el deslizamiento
        }, { passive: false });

        gameContainer.addEventListener('touchend', (e) => {
            if (gameOver || !gameStarted) return;

            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;

            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;

            // Determinar si es un deslizamiento horizontal o vertical
            if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > SWIPE_THRESHOLD) {
                // Deslizamiento horizontal
                if (dx > 0) {
                    movePlayer(1, 0); // Deslizar a la derecha
                } else {
                    movePlayer(-1, 0); // Deslizar a la izquierda
                }
            } else if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > SWIPE_THRESHOLD) { 
                // Deslizamiento vertical
                if (dy < 0) { // Deslizar hacia arriba (Y disminuye)
                    movePlayer(0, 1); // Mover hacia adelante
                }
                // No hay movimiento hacia abajo en este juego
            }
        });
        // --- Fin Lógica de Control Táctil ---

        // Envuelve los listeners en DOMContentLoaded
        document.addEventListener('DOMContentLoaded', () => {
            // Añadir listeners de eventos
            restartButton.addEventListener('click', resetGame); // Botón de reinicio
            
            // El botón de inicio ahora valida los campos antes de iniciar el juego
            startButton.addEventListener('click', resetGame); 

            // Event listeners para los nuevos botones de control móvil
            leftButton.addEventListener('click', () => {
                if (gameStarted && !gameOver) {
                    movePlayer(-1, 0);
                }
            });
            upButton.addEventListener('click', () => {
                if (gameStarted && !gameOver) {
                    movePlayer(0, 1);
                }
            });
            rightButton.addEventListener('click', () => {
                if (gameStarted && !gameOver) {
                    movePlayer(1, 0);
                }
            });

            // Control de movimiento del jugador con las teclas de flecha (para PC)
            document.addEventListener('keydown', (e) => {
                if (!gameStarted && e.key !== "Escape") return;
                if (gameOver) return;

                switch (e.key) {
                    case 'ArrowUp':
                        movePlayer(0, 1); // Mover hacia arriba
                        break;
                    case 'ArrowDown':
                        // movePlayer(0, -1); // Deshabilitado el movimiento hacia abajo
                        break;
                    case 'ArrowLeft':
                        movePlayer(-1, 0); // Mover hacia la izquierda
                        break;
                    case 'ArrowRight':
                        movePlayer(1, 0); // Mover hacia la derecha
                        break;
                }
            });

            // Configuración inicial al cargar la página
            playerPos = { x: Math.floor(GAME_WIDTH_TILES / 2), y: 1 }; // Posición inicial del jugador
            initLanes(); // Inicializar las filas
            updatePlayerPosition(); // Actualizar posición del jugador
        });
    </script>
</body>
</html>
